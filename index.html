<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="./vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>千木导航站</title>
  <script type="module"
    crossorigin>(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const n of document.querySelectorAll('link[rel="modulepreload"]')) i(n); new MutationObserver(n => { for (const s of n) if (s.type === "childList") for (const l of s.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && i(l) }).observe(document, { childList: !0, subtree: !0 }); function r(n) { const s = {}; return n.integrity && (s.integrity = n.integrity), n.referrerPolicy && (s.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? s.credentials = "include" : n.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function i(n) { if (n.ep) return; n.ep = !0; const s = r(n); fetch(n.href, s) } })();/**
* @vue/shared v3.5.20
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Br(e) { const t = Object.create(null); for (const r of e.split(",")) t[r] = 1; return r => r in t } const k = {}, Tt = [], Ve = () => { }, Bi = () => !1, ur = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Hr = e => e.startsWith("onUpdate:"), he = Object.assign, zr = (e, t) => { const r = e.indexOf(t); r > -1 && e.splice(r, 1) }, Vn = Object.prototype.hasOwnProperty, K = (e, t) => Vn.call(e, t), V = Array.isArray, Ot = e => ar(e) === "[object Map]", Xn = e => ar(e) === "[object Set]", z = e => typeof e == "function", ne = e => typeof e == "string", Dt = e => typeof e == "symbol", ie = e => e !== null && typeof e == "object", Hi = e => (ie(e) || z(e)) && z(e.then) && z(e.catch), $n = Object.prototype.toString, ar = e => $n.call(e), jn = e => ar(e).slice(8, -1), Gn = e => ar(e) === "[object Object]", Vr = e => ne(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, It = Br(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), dr = e => { const t = Object.create(null); return (r => t[r] || (t[r] = e(r))) }, Yn = /-(\w)/g, st = dr(e => e.replace(Yn, (t, r) => r ? r.toUpperCase() : "")), Wn = /\B([A-Z])/g, gt = dr(e => e.replace(Wn, "-$1").toLowerCase()), zi = dr(e => e.charAt(0).toUpperCase() + e.slice(1)), _r = dr(e => e ? `on${zi(e)}` : ""), nt = (e, t) => !Object.is(e, t), xr = (e, ...t) => { for (let r = 0; r < e.length; r++)e[r](...t) }, Vi = (e, t, r, i = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: i, value: r }) }, Kn = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let ai; const hr = () => ai || (ai = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Xr(e) { if (V(e)) { const t = {}; for (let r = 0; r < e.length; r++) { const i = e[r], n = ne(i) ? Qn(i) : Xr(i); if (n) for (const s in n) t[s] = n[s] } return t } else if (ne(e) || ie(e)) return e } const qn = /;(?![^(]*\))/g, Jn = /:([^]+)/, Zn = /\/\*[^]*?\*\//g; function Qn(e) { const t = {}; return e.replace(Zn, "").split(qn).forEach(r => { if (r) { const i = r.split(Jn); i.length > 1 && (t[i[0].trim()] = i[1].trim()) } }), t } function Yt(e) { let t = ""; if (ne(e)) t = e; else if (V(e)) for (let r = 0; r < e.length; r++) { const i = Yt(e[r]); i && (t += i + " ") } else if (ie(e)) for (const r in e) e[r] && (t += r + " "); return t.trim() } const kn = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", es = Br(kn); function Xi(e) { return !!e || e === "" }/**
* @vue/reactivity v3.5.20
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Te; class ts { constructor(t = !1) { this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Te, !t && Te && (this.index = (Te.scopes || (Te.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, r; if (this.scopes) for (t = 0, r = this.scopes.length; t < r; t++)this.scopes[t].pause(); for (t = 0, r = this.effects.length; t < r; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, r; if (this.scopes) for (t = 0, r = this.scopes.length; t < r; t++)this.scopes[t].resume(); for (t = 0, r = this.effects.length; t < r; t++)this.effects[t].resume() } } run(t) { if (this._active) { const r = Te; try { return Te = this, t() } finally { Te = r } } } on() { ++this._on === 1 && (this.prevScope = Te, Te = this) } off() { this._on > 0 && --this._on === 0 && (Te = this.prevScope, this.prevScope = void 0) } stop(t) { if (this._active) { this._active = !1; let r, i; for (r = 0, i = this.effects.length; r < i; r++)this.effects[r].stop(); for (this.effects.length = 0, r = 0, i = this.cleanups.length; r < i; r++)this.cleanups[r](); if (this.cleanups.length = 0, this.scopes) { for (r = 0, i = this.scopes.length; r < i; r++)this.scopes[r].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { const n = this.parent.scopes.pop(); n && n !== this && (this.parent.scopes[this.index] = n, n.index = this.index) } this.parent = void 0 } } } function rs() { return Te } let Q; const br = new WeakSet; class $i { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Te && Te.active && Te.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, br.has(this) && (br.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Gi(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, di(this), Yi(this); const t = Q, r = Oe; Q = this, Oe = !0; try { return this.fn() } finally { Wi(this), Q = t, Oe = r, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)Gr(t); this.deps = this.depsTail = void 0, di(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? br.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { Ar(this) && this.run() } get dirty() { return Ar(this) } } let ji = 0, Mt, Lt; function Gi(e, t = !1) { if (e.flags |= 8, t) { e.next = Lt, Lt = e; return } e.next = Mt, Mt = e } function $r() { ji++ } function jr() { if (--ji > 0) return; if (Lt) { let t = Lt; for (Lt = void 0; t;) { const r = t.next; t.next = void 0, t.flags &= -9, t = r } } let e; for (; Mt;) { let t = Mt; for (Mt = void 0; t;) { const r = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (i) { e || (e = i) } t = r } } if (e) throw e } function Yi(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function Wi(e) { let t, r = e.depsTail, i = r; for (; i;) { const n = i.prevDep; i.version === -1 ? (i === r && (r = n), Gr(i), is(i)) : t = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = n } e.deps = t, e.depsTail = r } function Ar(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (Ki(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function Ki(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Vt) || (e.globalVersion = Vt, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Ar(e)))) return; e.flags |= 2; const t = e.dep, r = Q, i = Oe; Q = e, Oe = !0; try { Yi(e); const n = e.fn(e._value); (t.version === 0 || nt(n, e._value)) && (e.flags |= 128, e._value = n, t.version++) } catch (n) { throw t.version++, n } finally { Q = r, Oe = i, Wi(e), e.flags &= -3 } } function Gr(e, t = !1) { const { dep: r, prevSub: i, nextSub: n } = e; if (i && (i.nextSub = n, e.prevSub = void 0), n && (n.prevSub = i, e.nextSub = void 0), r.subs === e && (r.subs = i, !i && r.computed)) { r.computed.flags &= -5; for (let s = r.computed.deps; s; s = s.nextDep)Gr(s, !0) } !t && !--r.sc && r.map && r.map.delete(r.key) } function is(e) { const { prevDep: t, nextDep: r } = e; t && (t.nextDep = r, e.prevDep = void 0), r && (r.prevDep = t, e.nextDep = void 0) } let Oe = !0; const qi = []; function Ze() { qi.push(Oe), Oe = !1 } function Qe() { const e = qi.pop(); Oe = e === void 0 ? !0 : e } function di(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const r = Q; Q = void 0; try { t() } finally { Q = r } } } let Vt = 0; class ns { constructor(t, r) { this.sub = t, this.dep = r, this.version = r.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class Yr { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0 } track(t) { if (!Q || !Oe || Q === this.computed) return; let r = this.activeLink; if (r === void 0 || r.sub !== Q) r = this.activeLink = new ns(Q, this), Q.deps ? (r.prevDep = Q.depsTail, Q.depsTail.nextDep = r, Q.depsTail = r) : Q.deps = Q.depsTail = r, Ji(r); else if (r.version === -1 && (r.version = this.version, r.nextDep)) { const i = r.nextDep; i.prevDep = r.prevDep, r.prevDep && (r.prevDep.nextDep = i), r.prevDep = Q.depsTail, r.nextDep = void 0, Q.depsTail.nextDep = r, Q.depsTail = r, Q.deps === r && (Q.deps = i) } return r } trigger(t) { this.version++, Vt++, this.notify(t) } notify(t) { $r(); try { for (let r = this.subs; r; r = r.prevSub)r.sub.notify() && r.sub.dep.notify() } finally { jr() } } } function Ji(e) { if (e.dep.sc++, e.sub.flags & 4) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let i = t.deps; i; i = i.nextDep)Ji(i) } const r = e.dep.subs; r !== e && (e.prevSub = r, r && (r.nextSub = e)), e.dep.subs = e } } const Dr = new WeakMap, ht = Symbol(""), Cr = Symbol(""), Xt = Symbol(""); function ae(e, t, r) { if (Oe && Q) { let i = Dr.get(e); i || Dr.set(e, i = new Map); let n = i.get(r); n || (i.set(r, n = new Yr), n.map = i, n.key = r), n.track() } } function Je(e, t, r, i, n, s) { const l = Dr.get(e); if (!l) { Vt++; return } const o = u => { u && u.trigger() }; if ($r(), t === "clear") l.forEach(o); else { const u = V(e), v = u && Vr(r); if (u && r === "length") { const d = Number(i); l.forEach((m, w) => { (w === "length" || w === Xt || !Dt(w) && w >= d) && o(m) }) } else switch ((r !== void 0 || l.has(void 0)) && o(l.get(r)), v && o(l.get(Xt)), t) { case "add": u ? v && o(l.get("length")) : (o(l.get(ht)), Ot(e) && o(l.get(Cr))); break; case "delete": u || (o(l.get(ht)), Ot(e) && o(l.get(Cr))); break; case "set": Ot(e) && o(l.get(ht)); break } } jr() } function bt(e) { const t = W(e); return t === e ? t : (ae(t, "iterate", Xt), Ie(e) ? t : t.map(me)) } function Wr(e) { return ae(e = W(e), "iterate", Xt), e } const ss = { __proto__: null, [Symbol.iterator]() { return yr(this, Symbol.iterator, me) }, concat(...e) { return bt(this).concat(...e.map(t => V(t) ? bt(t) : t)) }, entries() { return yr(this, "entries", e => (e[1] = me(e[1]), e)) }, every(e, t) { return Ke(this, "every", e, t, void 0, arguments) }, filter(e, t) { return Ke(this, "filter", e, t, r => r.map(me), arguments) }, find(e, t) { return Ke(this, "find", e, t, me, arguments) }, findIndex(e, t) { return Ke(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return Ke(this, "findLast", e, t, me, arguments) }, findLastIndex(e, t) { return Ke(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return Ke(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return Tr(this, "includes", e) }, indexOf(...e) { return Tr(this, "indexOf", e) }, join(e) { return bt(this).join(e) }, lastIndexOf(...e) { return Tr(this, "lastIndexOf", e) }, map(e, t) { return Ke(this, "map", e, t, void 0, arguments) }, pop() { return Ct(this, "pop") }, push(...e) { return Ct(this, "push", e) }, reduce(e, ...t) { return hi(this, "reduce", e, t) }, reduceRight(e, ...t) { return hi(this, "reduceRight", e, t) }, shift() { return Ct(this, "shift") }, some(e, t) { return Ke(this, "some", e, t, void 0, arguments) }, splice(...e) { return Ct(this, "splice", e) }, toReversed() { return bt(this).toReversed() }, toSorted(e) { return bt(this).toSorted(e) }, toSpliced(...e) { return bt(this).toSpliced(...e) }, unshift(...e) { return Ct(this, "unshift", e) }, values() { return yr(this, "values", me) } }; function yr(e, t, r) { const i = Wr(e), n = i[t](); return i !== e && !Ie(e) && (n._next = n.next, n.next = () => { const s = n._next(); return s.value && (s.value = r(s.value)), s }), n } const os = Array.prototype; function Ke(e, t, r, i, n, s) { const l = Wr(e), o = l !== e && !Ie(e), u = l[t]; if (u !== os[t]) { const m = u.apply(e, s); return o ? me(m) : m } let v = r; l !== e && (o ? v = function (m, w) { return r.call(this, me(m), w, e) } : r.length > 2 && (v = function (m, w) { return r.call(this, m, w, e) })); const d = u.call(l, v, i); return o && n ? n(d) : d } function hi(e, t, r, i) { const n = Wr(e); let s = r; return n !== e && (Ie(e) ? r.length > 3 && (s = function (l, o, u) { return r.call(this, l, o, u, e) }) : s = function (l, o, u) { return r.call(this, l, me(o), u, e) }), n[t](s, ...i) } function Tr(e, t, r) { const i = W(e); ae(i, "iterate", Xt); const n = i[t](...r); return (n === -1 || n === !1) && Zr(r[0]) ? (r[0] = W(r[0]), i[t](...r)) : n } function Ct(e, t, r = []) { Ze(), $r(); const i = W(e)[t].apply(e, r); return jr(), Qe(), i } const ls = Br("__proto__,__v_isRef,__isVue"), Zi = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Dt)); function cs(e) { Dt(e) || (e = String(e)); const t = W(this); return ae(t, "has", e), t.hasOwnProperty(e) } class Qi { constructor(t = !1, r = !1) { this._isReadonly = t, this._isShallow = r } get(t, r, i) { if (r === "__v_skip") return t.__v_skip; const n = this._isReadonly, s = this._isShallow; if (r === "__v_isReactive") return !n; if (r === "__v_isReadonly") return n; if (r === "__v_isShallow") return s; if (r === "__v_raw") return i === (n ? s ? _s : rn : s ? tn : en).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(i) ? t : void 0; const l = V(t); if (!n) { let u; if (l && (u = ss[r])) return u; if (r === "hasOwnProperty") return cs } const o = Reflect.get(t, r, de(t) ? t : i); return (Dt(r) ? Zi.has(r) : ls(r)) || (n || ae(t, "get", r), s) ? o : de(o) ? l && Vr(r) ? o : o.value : ie(o) ? n ? nn(o) : qr(o) : o } } class ki extends Qi { constructor(t = !1) { super(!1, t) } set(t, r, i, n) { let s = t[r]; if (!this._isShallow) { const u = pt(s); if (!Ie(i) && !pt(i) && (s = W(s), i = W(i)), !V(t) && de(s) && !de(i)) return u || (s.value = i), !0 } const l = V(t) && Vr(r) ? Number(r) < t.length : K(t, r), o = Reflect.set(t, r, i, de(t) ? t : n); return t === W(n) && (l ? nt(i, s) && Je(t, "set", r, i) : Je(t, "add", r, i)), o } deleteProperty(t, r) { const i = K(t, r); t[r]; const n = Reflect.deleteProperty(t, r); return n && i && Je(t, "delete", r, void 0), n } has(t, r) { const i = Reflect.has(t, r); return (!Dt(r) || !Zi.has(r)) && ae(t, "has", r), i } ownKeys(t) { return ae(t, "iterate", V(t) ? "length" : ht), Reflect.ownKeys(t) } } class fs extends Qi { constructor(t = !1) { super(!0, t) } set(t, r) { return !0 } deleteProperty(t, r) { return !0 } } const us = new ki, as = new fs, ds = new ki(!0); const Fr = e => e, Qt = e => Reflect.getPrototypeOf(e); function hs(e, t, r) { return function (...i) { const n = this.__v_raw, s = W(n), l = Ot(s), o = e === "entries" || e === Symbol.iterator && l, u = e === "keys" && l, v = n[e](...i), d = r ? Fr : t ? Pr : me; return !t && ae(s, "iterate", u ? Cr : ht), { next() { const { value: m, done: w } = v.next(); return w ? { value: m, done: w } : { value: o ? [d(m[0]), d(m[1])] : d(m), done: w } }, [Symbol.iterator]() { return this } } } } function kt(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function ps(e, t) { const r = { get(n) { const s = this.__v_raw, l = W(s), o = W(n); e || (nt(n, o) && ae(l, "get", n), ae(l, "get", o)); const { has: u } = Qt(l), v = t ? Fr : e ? Pr : me; if (u.call(l, n)) return v(s.get(n)); if (u.call(l, o)) return v(s.get(o)); s !== l && s.get(n) }, get size() { const n = this.__v_raw; return !e && ae(W(n), "iterate", ht), n.size }, has(n) { const s = this.__v_raw, l = W(s), o = W(n); return e || (nt(n, o) && ae(l, "has", n), ae(l, "has", o)), n === o ? s.has(n) : s.has(n) || s.has(o) }, forEach(n, s) { const l = this, o = l.__v_raw, u = W(o), v = t ? Fr : e ? Pr : me; return !e && ae(u, "iterate", ht), o.forEach((d, m) => n.call(s, v(d), v(m), l)) } }; return he(r, e ? { add: kt("add"), set: kt("set"), delete: kt("delete"), clear: kt("clear") } : { add(n) { !t && !Ie(n) && !pt(n) && (n = W(n)); const s = W(this); return Qt(s).has.call(s, n) || (s.add(n), Je(s, "add", n, n)), this }, set(n, s) { !t && !Ie(s) && !pt(s) && (s = W(s)); const l = W(this), { has: o, get: u } = Qt(l); let v = o.call(l, n); v || (n = W(n), v = o.call(l, n)); const d = u.call(l, n); return l.set(n, s), v ? nt(s, d) && Je(l, "set", n, s) : Je(l, "add", n, s), this }, delete(n) { const s = W(this), { has: l, get: o } = Qt(s); let u = l.call(s, n); u || (n = W(n), u = l.call(s, n)), o && o.call(s, n); const v = s.delete(n); return u && Je(s, "delete", n, void 0), v }, clear() { const n = W(this), s = n.size !== 0, l = n.clear(); return s && Je(n, "clear", void 0, void 0), l } }), ["keys", "values", "entries", Symbol.iterator].forEach(n => { r[n] = hs(n, e, t) }), r } function Kr(e, t) { const r = ps(e, t); return (i, n, s) => n === "__v_isReactive" ? !e : n === "__v_isReadonly" ? e : n === "__v_raw" ? i : Reflect.get(K(r, n) && n in i ? r : i, n, s) } const gs = { get: Kr(!1, !1) }, ms = { get: Kr(!1, !0) }, vs = { get: Kr(!0, !1) }; const en = new WeakMap, tn = new WeakMap, rn = new WeakMap, _s = new WeakMap; function xs(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function bs(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : xs(jn(e)) } function qr(e) { return pt(e) ? e : Jr(e, !1, us, gs, en) } function ys(e) { return Jr(e, !1, ds, ms, tn) } function nn(e) { return Jr(e, !0, as, vs, rn) } function Jr(e, t, r, i, n) { if (!ie(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const s = bs(e); if (s === 0) return e; const l = n.get(e); if (l) return l; const o = new Proxy(e, s === 2 ? i : r); return n.set(e, o), o } function Ut(e) { return pt(e) ? Ut(e.__v_raw) : !!(e && e.__v_isReactive) } function pt(e) { return !!(e && e.__v_isReadonly) } function Ie(e) { return !!(e && e.__v_isShallow) } function Zr(e) { return e ? !!e.__v_raw : !1 } function W(e) { const t = e && e.__v_raw; return t ? W(t) : e } function Ts(e) { return !K(e, "__v_skip") && Object.isExtensible(e) && Vi(e, "__v_skip", !0), e } const me = e => ie(e) ? qr(e) : e, Pr = e => ie(e) ? nn(e) : e; function de(e) { return e ? e.__v_isRef === !0 : !1 } function sn(e) { return Ss(e, !1) } function Ss(e, t) { return de(e) ? e : new Es(e, t) } class Es { constructor(t, r) { this.dep = new Yr, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = r ? t : W(t), this._value = r ? t : me(t), this.__v_isShallow = r } get value() { return this.dep.track(), this._value } set value(t) { const r = this._rawValue, i = this.__v_isShallow || Ie(t) || pt(t); t = i ? t : W(t), nt(t, r) && (this._rawValue = t, this._value = i ? t : me(t), this.dep.trigger()) } } function Qr(e) { return de(e) ? e.value : e } const Rs = { get: (e, t, r) => t === "__v_raw" ? e : Qr(Reflect.get(e, t, r)), set: (e, t, r, i) => { const n = e[t]; return de(n) && !de(r) ? (n.value = r, !0) : Reflect.set(e, t, r, i) } }; function on(e) { return Ut(e) ? e : new Proxy(e, Rs) } class ws { constructor(t, r, i) { this.fn = t, this.setter = r, this._value = void 0, this.dep = new Yr(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Vt - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !r, this.isSSR = i } notify() { if (this.flags |= 16, !(this.flags & 8) && Q !== this) return Gi(this, !0), !0 } get value() { const t = this.dep.track(); return Ki(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function As(e, t, r = !1) { let i, n; return z(e) ? i = e : (i = e.get, n = e.set), new ws(i, n, r) } const er = {}, sr = new WeakMap; let dt; function Ds(e, t = !1, r = dt) { if (r) { let i = sr.get(r); i || sr.set(r, i = []), i.push(e) } } function Cs(e, t, r = k) { const { immediate: i, deep: n, once: s, scheduler: l, augmentJob: o, call: u } = r, v = M => n ? M : Ie(M) || n === !1 || n === 0 ? it(M, 1) : it(M); let d, m, w, C, P = !1, N = !1; if (de(e) ? (m = () => e.value, P = Ie(e)) : Ut(e) ? (m = () => v(e), P = !0) : V(e) ? (N = !0, P = e.some(M => Ut(M) || Ie(M)), m = () => e.map(M => { if (de(M)) return M.value; if (Ut(M)) return v(M); if (z(M)) return u ? u(M, 2) : M() })) : z(e) ? t ? m = u ? () => u(e, 2) : e : m = () => { if (w) { Ze(); try { w() } finally { Qe() } } const M = dt; dt = d; try { return u ? u(e, 3, [C]) : e(C) } finally { dt = M } } : m = Ve, t && n) { const M = m, re = n === !0 ? 1 / 0 : n; m = () => it(M(), re) } const te = rs(), H = () => { d.stop(), te && te.active && zr(te.effects, d) }; if (s && t) { const M = t; t = (...re) => { M(...re), H() } } let G = N ? new Array(e.length).fill(er) : er; const U = M => { if (!(!(d.flags & 1) || !d.dirty && !M)) if (t) { const re = d.run(); if (n || P || (N ? re.some((Me, we) => nt(Me, G[we])) : nt(re, G))) { w && w(); const Me = dt; dt = d; try { const we = [re, G === er ? void 0 : N && G[0] === er ? [] : G, C]; G = re, u ? u(t, 3, we) : t(...we) } finally { dt = Me } } } else d.run() }; return o && o(U), d = new $i(m), d.scheduler = l ? () => l(U, !1) : U, C = M => Ds(M, !1, d), w = d.onStop = () => { const M = sr.get(d); if (M) { if (u) u(M, 4); else for (const re of M) re(); sr.delete(d) } }, t ? i ? U(!0) : G = d.run() : l ? l(U.bind(null, !0), !0) : d.run(), H.pause = d.pause.bind(d), H.resume = d.resume.bind(d), H.stop = H, H } function it(e, t = 1 / 0, r) { if (t <= 0 || !ie(e) || e.__v_skip || (r = r || new Set, r.has(e))) return e; if (r.add(e), t--, de(e)) it(e.value, t, r); else if (V(e)) for (let i = 0; i < e.length; i++)it(e[i], t, r); else if (Xn(e) || Ot(e)) e.forEach(i => { it(i, t, r) }); else if (Gn(e)) { for (const i in e) it(e[i], t, r); for (const i of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, i) && it(e[i], t, r) } return e }/**
* @vue/runtime-core v3.5.20
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Wt(e, t, r, i) { try { return i ? e(...i) : e() } catch (n) { pr(n, t, r) } } function $e(e, t, r, i) { if (z(e)) { const n = Wt(e, t, r, i); return n && Hi(n) && n.catch(s => { pr(s, t, r) }), n } if (V(e)) { const n = []; for (let s = 0; s < e.length; s++)n.push($e(e[s], t, r, i)); return n } } function pr(e, t, r, i = !0) { const n = t ? t.vnode : null, { errorHandler: s, throwUnhandledErrorInProduction: l } = t && t.appContext.config || k; if (t) { let o = t.parent; const u = t.proxy, v = `https://vuejs.org/error-reference/#runtime-${r}`; for (; o;) { const d = o.ec; if (d) { for (let m = 0; m < d.length; m++)if (d[m](e, u, v) === !1) return } o = o.parent } if (s) { Ze(), Wt(s, null, 10, [e, u, v]), Qe(); return } } Fs(e, r, n, i, l) } function Fs(e, t, r, i = !0, n = !1) { if (n) throw e; console.error(e) } const ve = []; let Ne = -1; const St = []; let tt = null, yt = 0; const ln = Promise.resolve(); let or = null; function Ps(e) { const t = or || ln; return e ? t.then(this ? e.bind(this) : e) : t } function Os(e) { let t = Ne + 1, r = ve.length; for (; t < r;) { const i = t + r >>> 1, n = ve[i], s = $t(n); s < e || s === e && n.flags & 2 ? t = i + 1 : r = i } return t } function kr(e) { if (!(e.flags & 1)) { const t = $t(e), r = ve[ve.length - 1]; !r || !(e.flags & 2) && t >= $t(r) ? ve.push(e) : ve.splice(Os(t), 0, e), e.flags |= 1, cn() } } function cn() { or || (or = ln.then(un)) } function Is(e) { V(e) ? St.push(...e) : tt && e.id === -1 ? tt.splice(yt + 1, 0, e) : e.flags & 1 || (St.push(e), e.flags |= 1), cn() } function pi(e, t, r = Ne + 1) { for (; r < ve.length; r++) { const i = ve[r]; if (i && i.flags & 2) { if (e && i.id !== e.uid) continue; ve.splice(r, 1), r--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2) } } } function fn(e) { if (St.length) { const t = [...new Set(St)].sort((r, i) => $t(r) - $t(i)); if (St.length = 0, tt) { tt.push(...t); return } for (tt = t, yt = 0; yt < tt.length; yt++) { const r = tt[yt]; r.flags & 4 && (r.flags &= -2), r.flags & 8 || r(), r.flags &= -2 } tt = null, yt = 0 } } const $t = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function un(e) { try { for (Ne = 0; Ne < ve.length; Ne++) { const t = ve[Ne]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), Wt(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2)) } } finally { for (; Ne < ve.length; Ne++) { const t = ve[Ne]; t && (t.flags &= -2) } Ne = -1, ve.length = 0, fn(), or = null, (ve.length || St.length) && un() } } let ze = null, an = null; function lr(e) { const t = ze; return ze = e, an = e && e.type.__scopeId || null, t } function Ms(e, t = ze, r) { if (!t || e._n) return e; const i = (...n) => { i._d && Si(-1); const s = lr(t); let l; try { l = e(...n) } finally { lr(s), i._d && Si(1) } return l }; return i._n = !0, i._c = !0, i._d = !0, i } function ut(e, t, r, i) { const n = e.dirs, s = t && t.dirs; for (let l = 0; l < n.length; l++) { const o = n[l]; s && (o.oldValue = s[l].value); let u = o.dir[i]; u && (Ze(), $e(u, r, 8, [e.el, o, e, t]), Qe()) } } const Ls = Symbol("_vte"), Us = e => e.__isTeleport, Ns = Symbol("_leaveCb"); function ei(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, ei(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t }/*! #__NO_SIDE_EFFECTS__ */function dn(e, t) { return z(e) ? he({ name: e.name }, t, { setup: e }) : e } function hn(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function Nt(e, t, r, i, n = !1) { if (V(e)) { e.forEach((P, N) => Nt(P, t && (V(t) ? t[N] : t), r, i, n)); return } if (Bt(i) && !n) { i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && Nt(e, t, r, i.component.subTree); return } const s = i.shapeFlag & 4 ? ci(i.component) : i.el, l = n ? null : s, { i: o, r: u } = e, v = t && t.r, d = o.refs === k ? o.refs = {} : o.refs, m = o.setupState, w = W(m), C = m === k ? Bi : P => K(w, P); if (v != null && v !== u) { if (ne(v)) d[v] = null, C(v) && (m[v] = null); else if (de(v)) { v.value = null; const P = t; P.k && (d[P.k] = null) } } if (z(u)) Wt(u, o, 12, [l, d]); else { const P = ne(u), N = de(u); if (P || N) { const te = () => { if (e.f) { const H = P ? C(u) ? m[u] : d[u] : u.value; if (n) V(H) && zr(H, s); else if (V(H)) H.includes(s) || H.push(s); else if (P) d[u] = [s], C(u) && (m[u] = d[u]); else { const G = [s]; u.value = G, e.k && (d[e.k] = G) } } else P ? (d[u] = l, C(u) && (m[u] = l)) : N && (u.value = l, e.k && (d[e.k] = l)) }; l ? (te.id = -1, Ee(te, r)) : te() } } } hr().requestIdleCallback; hr().cancelIdleCallback; const Bt = e => !!e.type.__asyncLoader, pn = e => e.type.__isKeepAlive; function Bs(e, t) { gn(e, "a", t) } function Hs(e, t) { gn(e, "da", t) } function gn(e, t, r = _e) { const i = e.__wdc || (e.__wdc = () => { let n = r; for (; n;) { if (n.isDeactivated) return; n = n.parent } return e() }); if (gr(t, i, r), r) { let n = r.parent; for (; n && n.parent;)pn(n.parent.vnode) && zs(i, t, r, n), n = n.parent } } function zs(e, t, r, i) { const n = gr(t, e, i, !0); mn(() => { zr(i[t], n) }, r) } function gr(e, t, r = _e, i = !1) { if (r) { const n = r[e] || (r[e] = []), s = t.__weh || (t.__weh = (...l) => { Ze(); const o = Kt(r), u = $e(t, r, e, l); return o(), Qe(), u }); return i ? n.unshift(s) : n.push(s), s } } const ke = e => (t, r = _e) => { (!Gt || e === "sp") && gr(e, (...i) => t(...i), r) }, Vs = ke("bm"), ti = ke("m"), Xs = ke("bu"), $s = ke("u"), js = ke("bum"), mn = ke("um"), Gs = ke("sp"), Ys = ke("rtg"), Ws = ke("rtc"); function Ks(e, t = _e) { gr("ec", e, t) } const qs = Symbol.for("v-ndc"), Or = e => e ? Un(e) ? ci(e) : Or(e.parent) : null, Ht = he(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => Or(e.parent), $root: e => Or(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => _n(e), $forceUpdate: e => e.f || (e.f = () => { kr(e.update) }), $nextTick: e => e.n || (e.n = Ps.bind(e.proxy)), $watch: e => _o.bind(e) }), Sr = (e, t) => e !== k && !e.__isScriptSetup && K(e, t), Js = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: r, setupState: i, data: n, props: s, accessCache: l, type: o, appContext: u } = e; let v; if (t[0] !== "$") { const C = l[t]; if (C !== void 0) switch (C) { case 1: return i[t]; case 2: return n[t]; case 4: return r[t]; case 3: return s[t] } else { if (Sr(i, t)) return l[t] = 1, i[t]; if (n !== k && K(n, t)) return l[t] = 2, n[t]; if ((v = e.propsOptions[0]) && K(v, t)) return l[t] = 3, s[t]; if (r !== k && K(r, t)) return l[t] = 4, r[t]; Ir && (l[t] = 0) } } const d = Ht[t]; let m, w; if (d) return t === "$attrs" && ae(e.attrs, "get", ""), d(e); if ((m = o.__cssModules) && (m = m[t])) return m; if (r !== k && K(r, t)) return l[t] = 4, r[t]; if (w = u.config.globalProperties, K(w, t)) return w[t] }, set({ _: e }, t, r) { const { data: i, setupState: n, ctx: s } = e; return Sr(n, t) ? (n[t] = r, !0) : i !== k && K(i, t) ? (i[t] = r, !0) : K(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (s[t] = r, !0) }, has({ _: { data: e, setupState: t, accessCache: r, ctx: i, appContext: n, propsOptions: s, type: l } }, o) { let u, v; return !!(r[o] || e !== k && o[0] !== "$" && K(e, o) || Sr(t, o) || (u = s[0]) && K(u, o) || K(i, o) || K(Ht, o) || K(n.config.globalProperties, o) || (v = l.__cssModules) && v[o]) }, defineProperty(e, t, r) { return r.get != null ? e._.accessCache[t] = 0 : K(r, "value") && this.set(e, t, r.value, null), Reflect.defineProperty(e, t, r) } }; function gi(e) { return V(e) ? e.reduce((t, r) => (t[r] = null, t), {}) : e } let Ir = !0; function Zs(e) { const t = _n(e), r = e.proxy, i = e.ctx; Ir = !1, t.beforeCreate && mi(t.beforeCreate, e, "bc"); const { data: n, computed: s, methods: l, watch: o, provide: u, inject: v, created: d, beforeMount: m, mounted: w, beforeUpdate: C, updated: P, activated: N, deactivated: te, beforeDestroy: H, beforeUnmount: G, destroyed: U, unmounted: M, render: re, renderTracked: Me, renderTriggered: we, errorCaptured: Le, serverPrefetch: mt, expose: je, inheritAttrs: ot, components: vt, directives: _t, filters: le } = t; if (v && Qs(v, i, null), l) for (const J in l) { const Y = l[J]; z(Y) && (i[J] = Y.bind(r)) } if (n) { const J = n.call(r, r); ie(J) && (e.data = qr(J)) } if (Ir = !0, s) for (const J in s) { const Y = s[J], fe = z(Y) ? Y.bind(r, r) : z(Y.get) ? Y.get.bind(r, r) : Ve, et = !z(Y) && z(Y.set) ? Y.set.bind(r) : Ve, Se = Xo({ get: fe, set: et }); Object.defineProperty(i, J, { enumerable: !0, configurable: !0, get: () => Se.value, set: Z => Se.value = Z }) } if (o) for (const J in o) vn(o[J], i, r, J); if (u) { const J = z(u) ? u.call(r) : u; Reflect.ownKeys(J).forEach(Y => { no(Y, J[Y]) }) } d && mi(d, e, "c"); function I(J, Y) { V(Y) ? Y.forEach(fe => J(fe.bind(r))) : Y && J(Y.bind(r)) } if (I(Vs, m), I(ti, w), I(Xs, C), I($s, P), I(Bs, N), I(Hs, te), I(Ks, Le), I(Ws, Me), I(Ys, we), I(js, G), I(mn, M), I(Gs, mt), V(je)) if (je.length) { const J = e.exposed || (e.exposed = {}); je.forEach(Y => { Object.defineProperty(J, Y, { get: () => r[Y], set: fe => r[Y] = fe, enumerable: !0 }) }) } else e.exposed || (e.exposed = {}); re && e.render === Ve && (e.render = re), ot != null && (e.inheritAttrs = ot), vt && (e.components = vt), _t && (e.directives = _t), mt && hn(e) } function Qs(e, t, r = Ve) { V(e) && (e = Mr(e)); for (const i in e) { const n = e[i]; let s; ie(n) ? "default" in n ? s = tr(n.from || i, n.default, !0) : s = tr(n.from || i) : s = tr(n), de(s) ? Object.defineProperty(t, i, { enumerable: !0, configurable: !0, get: () => s.value, set: l => s.value = l }) : t[i] = s } } function mi(e, t, r) { $e(V(e) ? e.map(i => i.bind(t.proxy)) : e.bind(t.proxy), t, r) } function vn(e, t, r, i) { let n = i.includes(".") ? Pn(r, i) : () => r[i]; if (ne(e)) { const s = t[e]; z(s) && Rt(n, s) } else if (z(e)) Rt(n, e.bind(r)); else if (ie(e)) if (V(e)) e.forEach(s => vn(s, t, r, i)); else { const s = z(e.handler) ? e.handler.bind(r) : t[e.handler]; z(s) && Rt(n, s, e) } } function _n(e) { const t = e.type, { mixins: r, extends: i } = t, { mixins: n, optionsCache: s, config: { optionMergeStrategies: l } } = e.appContext, o = s.get(t); let u; return o ? u = o : !n.length && !r && !i ? u = t : (u = {}, n.length && n.forEach(v => cr(u, v, l, !0)), cr(u, t, l)), ie(t) && s.set(t, u), u } function cr(e, t, r, i = !1) { const { mixins: n, extends: s } = t; s && cr(e, s, r, !0), n && n.forEach(l => cr(e, l, r, !0)); for (const l in t) if (!(i && l === "expose")) { const o = ks[l] || r && r[l]; e[l] = o ? o(e[l], t[l]) : t[l] } return e } const ks = { data: vi, props: _i, emits: _i, methods: Pt, computed: Pt, beforeCreate: ge, created: ge, beforeMount: ge, mounted: ge, beforeUpdate: ge, updated: ge, beforeDestroy: ge, beforeUnmount: ge, destroyed: ge, unmounted: ge, activated: ge, deactivated: ge, errorCaptured: ge, serverPrefetch: ge, components: Pt, directives: Pt, watch: to, provide: vi, inject: eo }; function vi(e, t) { return t ? e ? function () { return he(z(e) ? e.call(this, this) : e, z(t) ? t.call(this, this) : t) } : t : e } function eo(e, t) { return Pt(Mr(e), Mr(t)) } function Mr(e) { if (V(e)) { const t = {}; for (let r = 0; r < e.length; r++)t[e[r]] = e[r]; return t } return e } function ge(e, t) { return e ? [...new Set([].concat(e, t))] : t } function Pt(e, t) { return e ? he(Object.create(null), e, t) : t } function _i(e, t) { return e ? V(e) && V(t) ? [...new Set([...e, ...t])] : he(Object.create(null), gi(e), gi(t ?? {})) : t } function to(e, t) { if (!e) return t; if (!t) return e; const r = he(Object.create(null), e); for (const i in t) r[i] = ge(e[i], t[i]); return r } function xn() { return { app: null, config: { isNativeTag: Bi, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let ro = 0; function io(e, t) { return function (i, n = null) { z(i) || (i = he({}, i)), n != null && !ie(n) && (n = null); const s = xn(), l = new WeakSet, o = []; let u = !1; const v = s.app = { _uid: ro++, _component: i, _props: n, _container: null, _context: s, _instance: null, version: $o, get config() { return s.config }, set config(d) { }, use(d, ...m) { return l.has(d) || (d && z(d.install) ? (l.add(d), d.install(v, ...m)) : z(d) && (l.add(d), d(v, ...m))), v }, mixin(d) { return s.mixins.includes(d) || s.mixins.push(d), v }, component(d, m) { return m ? (s.components[d] = m, v) : s.components[d] }, directive(d, m) { return m ? (s.directives[d] = m, v) : s.directives[d] }, mount(d, m, w) { if (!u) { const C = v._ceVNode || Xe(i, n); return C.appContext = s, w === !0 ? w = "svg" : w === !1 && (w = void 0), e(C, d, w), u = !0, v._container = d, d.__vue_app__ = v, ci(C.component) } }, onUnmount(d) { o.push(d) }, unmount() { u && ($e(o, v._instance, 16), e(null, v._container), delete v._container.__vue_app__) }, provide(d, m) { return s.provides[d] = m, v }, runWithContext(d) { const m = Et; Et = v; try { return d() } finally { Et = m } } }; return v } } let Et = null; function no(e, t) { if (_e) { let r = _e.provides; const i = _e.parent && _e.parent.provides; i === r && (r = _e.provides = Object.create(i)), r[e] = t } } function tr(e, t, r = !1) { const i = Uo(); if (i || Et) { let n = Et ? Et._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0; if (n && e in n) return n[e]; if (arguments.length > 1) return r && z(t) ? t.call(i && i.proxy) : t } } const bn = {}, yn = () => Object.create(bn), Tn = e => Object.getPrototypeOf(e) === bn; function so(e, t, r, i = !1) { const n = {}, s = yn(); e.propsDefaults = Object.create(null), Sn(e, t, n, s); for (const l in e.propsOptions[0]) l in n || (n[l] = void 0); r ? e.props = i ? n : ys(n) : e.type.props ? e.props = n : e.props = s, e.attrs = s } function oo(e, t, r, i) { const { props: n, attrs: s, vnode: { patchFlag: l } } = e, o = W(n), [u] = e.propsOptions; let v = !1; if ((i || l > 0) && !(l & 16)) { if (l & 8) { const d = e.vnode.dynamicProps; for (let m = 0; m < d.length; m++) { let w = d[m]; if (mr(e.emitsOptions, w)) continue; const C = t[w]; if (u) if (K(s, w)) C !== s[w] && (s[w] = C, v = !0); else { const P = st(w); n[P] = Lr(u, o, P, C, e, !1) } else C !== s[w] && (s[w] = C, v = !0) } } } else { Sn(e, t, n, s) && (v = !0); let d; for (const m in o) (!t || !K(t, m) && ((d = gt(m)) === m || !K(t, d))) && (u ? r && (r[m] !== void 0 || r[d] !== void 0) && (n[m] = Lr(u, o, m, void 0, e, !0)) : delete n[m]); if (s !== o) for (const m in s) (!t || !K(t, m)) && (delete s[m], v = !0) } v && Je(e.attrs, "set", "") } function Sn(e, t, r, i) { const [n, s] = e.propsOptions; let l = !1, o; if (t) for (let u in t) { if (It(u)) continue; const v = t[u]; let d; n && K(n, d = st(u)) ? !s || !s.includes(d) ? r[d] = v : (o || (o = {}))[d] = v : mr(e.emitsOptions, u) || (!(u in i) || v !== i[u]) && (i[u] = v, l = !0) } if (s) { const u = W(r), v = o || k; for (let d = 0; d < s.length; d++) { const m = s[d]; r[m] = Lr(n, u, m, v[m], e, !K(v, m)) } } return l } function Lr(e, t, r, i, n, s) { const l = e[r]; if (l != null) { const o = K(l, "default"); if (o && i === void 0) { const u = l.default; if (l.type !== Function && !l.skipFactory && z(u)) { const { propsDefaults: v } = n; if (r in v) i = v[r]; else { const d = Kt(n); i = v[r] = u.call(null, t), d() } } else i = u; n.ce && n.ce._setProp(r, i) } l[0] && (s && !o ? i = !1 : l[1] && (i === "" || i === gt(r)) && (i = !0)) } return i } const lo = new WeakMap; function En(e, t, r = !1) { const i = r ? lo : t.propsCache, n = i.get(e); if (n) return n; const s = e.props, l = {}, o = []; let u = !1; if (!z(e)) { const d = m => { u = !0; const [w, C] = En(m, t, !0); he(l, w), C && o.push(...C) }; !r && t.mixins.length && t.mixins.forEach(d), e.extends && d(e.extends), e.mixins && e.mixins.forEach(d) } if (!s && !u) return ie(e) && i.set(e, Tt), Tt; if (V(s)) for (let d = 0; d < s.length; d++) { const m = st(s[d]); xi(m) && (l[m] = k) } else if (s) for (const d in s) { const m = st(d); if (xi(m)) { const w = s[d], C = l[m] = V(w) || z(w) ? { type: w } : he({}, w), P = C.type; let N = !1, te = !0; if (V(P)) for (let H = 0; H < P.length; ++H) { const G = P[H], U = z(G) && G.name; if (U === "Boolean") { N = !0; break } else U === "String" && (te = !1) } else N = z(P) && P.name === "Boolean"; C[0] = N, C[1] = te, (N || K(C, "default")) && o.push(m) } } const v = [l, o]; return ie(e) && i.set(e, v), v } function xi(e) { return e[0] !== "$" && !It(e) } const ri = e => e === "_" || e === "_ctx" || e === "$stable", ii = e => V(e) ? e.map(He) : [He(e)], co = (e, t, r) => { if (t._n) return t; const i = Ms((...n) => ii(t(...n)), r); return i._c = !1, i }, Rn = (e, t, r) => { const i = e._ctx; for (const n in e) { if (ri(n)) continue; const s = e[n]; if (z(s)) t[n] = co(n, s, i); else if (s != null) { const l = ii(s); t[n] = () => l } } }, wn = (e, t) => { const r = ii(t); e.slots.default = () => r }, An = (e, t, r) => { for (const i in t) (r || !ri(i)) && (e[i] = t[i]) }, fo = (e, t, r) => { const i = e.slots = yn(); if (e.vnode.shapeFlag & 32) { const n = t._; n ? (An(i, t, r), r && Vi(i, "_", n, !0)) : Rn(t, i) } else t && wn(e, t) }, uo = (e, t, r) => { const { vnode: i, slots: n } = e; let s = !0, l = k; if (i.shapeFlag & 32) { const o = t._; o ? r && o === 1 ? s = !1 : An(n, t, r) : (s = !t.$stable, Rn(t, n)), l = t } else t && (wn(e, t), l = { default: 1 }); if (s) for (const o in n) !ri(o) && l[o] == null && delete n[o] }, Ee = Ro; function ao(e) { return ho(e) } function ho(e, t) { const r = hr(); r.__VUE__ = !0; const { insert: i, remove: n, patchProp: s, createElement: l, createText: o, createComment: u, setText: v, setElementText: d, parentNode: m, nextSibling: w, setScopeId: C = Ve, insertStaticContent: P } = e, N = (c, a, h, b = null, x = null, _ = null, R = void 0, E = null, S = !!a.dynamicChildren) => { if (c === a) return; c && !Ft(c, a) && (b = Ae(c), Z(c, x, _, !0), c = null), a.patchFlag === -2 && (S = !1, a.dynamicChildren = null); const { type: y, ref: O, shapeFlag: A } = a; switch (y) { case vr: te(c, a, h, b); break; case wt: H(c, a, h, b); break; case rr: c == null && G(a, h, b, R); break; case Be: vt(c, a, h, b, x, _, R, E, S); break; default: A & 1 ? re(c, a, h, b, x, _, R, E, S) : A & 6 ? _t(c, a, h, b, x, _, R, E, S) : (A & 64 || A & 128) && y.process(c, a, h, b, x, _, R, E, S, De) }O != null && x ? Nt(O, c && c.ref, _, a || c, !a) : O == null && c && c.ref != null && Nt(c.ref, null, _, c, !0) }, te = (c, a, h, b) => { if (c == null) i(a.el = o(a.children), h, b); else { const x = a.el = c.el; a.children !== c.children && v(x, a.children) } }, H = (c, a, h, b) => { c == null ? i(a.el = u(a.children || ""), h, b) : a.el = c.el }, G = (c, a, h, b) => { [c.el, c.anchor] = P(c.children, a, h, b, c.el, c.anchor) }, U = ({ el: c, anchor: a }, h, b) => { let x; for (; c && c !== a;)x = w(c), i(c, h, b), c = x; i(a, h, b) }, M = ({ el: c, anchor: a }) => { let h; for (; c && c !== a;)h = w(c), n(c), c = h; n(a) }, re = (c, a, h, b, x, _, R, E, S) => { a.type === "svg" ? R = "svg" : a.type === "math" && (R = "mathml"), c == null ? Me(a, h, b, x, _, R, E, S) : mt(c, a, x, _, R, E, S) }, Me = (c, a, h, b, x, _, R, E) => { let S, y; const { props: O, shapeFlag: A, transition: F, dirs: L } = c; if (S = c.el = l(c.type, _, O && O.is, O), A & 8 ? d(S, c.children) : A & 16 && Le(c.children, S, null, b, x, Er(c, _), R, E), L && ut(c, null, b, "created"), we(S, c, c.scopeId, R, b), O) { for (const q in O) q !== "value" && !It(q) && s(S, q, null, O[q], _, b); "value" in O && s(S, "value", null, O.value, _), (y = O.onVnodeBeforeMount) && Ue(y, b, c) } L && ut(c, null, b, "beforeMount"); const X = po(x, F); X && F.beforeEnter(S), i(S, a, h), ((y = O && O.onVnodeMounted) || X || L) && Ee(() => { y && Ue(y, b, c), X && F.enter(S), L && ut(c, null, b, "mounted") }, x) }, we = (c, a, h, b, x) => { if (h && C(c, h), b) for (let _ = 0; _ < b.length; _++)C(c, b[_]); if (x) { let _ = x.subTree; if (a === _ || In(_.type) && (_.ssContent === a || _.ssFallback === a)) { const R = x.vnode; we(c, R, R.scopeId, R.slotScopeIds, x.parent) } } }, Le = (c, a, h, b, x, _, R, E, S = 0) => { for (let y = S; y < c.length; y++) { const O = c[y] = E ? rt(c[y]) : He(c[y]); N(null, O, a, h, b, x, _, R, E) } }, mt = (c, a, h, b, x, _, R) => { const E = a.el = c.el; let { patchFlag: S, dynamicChildren: y, dirs: O } = a; S |= c.patchFlag & 16; const A = c.props || k, F = a.props || k; let L; if (h && at(h, !1), (L = F.onVnodeBeforeUpdate) && Ue(L, h, a, c), O && ut(a, c, h, "beforeUpdate"), h && at(h, !0), (A.innerHTML && F.innerHTML == null || A.textContent && F.textContent == null) && d(E, ""), y ? je(c.dynamicChildren, y, E, h, b, Er(a, x), _) : R || Y(c, a, E, null, h, b, Er(a, x), _, !1), S > 0) { if (S & 16) ot(E, A, F, h, x); else if (S & 2 && A.class !== F.class && s(E, "class", null, F.class, x), S & 4 && s(E, "style", A.style, F.style, x), S & 8) { const X = a.dynamicProps; for (let q = 0; q < X.length; q++) { const j = X[q], ue = A[j], oe = F[j]; (oe !== ue || j === "value") && s(E, j, ue, oe, x, h) } } S & 1 && c.children !== a.children && d(E, a.children) } else !R && y == null && ot(E, A, F, h, x); ((L = F.onVnodeUpdated) || O) && Ee(() => { L && Ue(L, h, a, c), O && ut(a, c, h, "updated") }, b) }, je = (c, a, h, b, x, _, R) => { for (let E = 0; E < a.length; E++) { const S = c[E], y = a[E], O = S.el && (S.type === Be || !Ft(S, y) || S.shapeFlag & 198) ? m(S.el) : h; N(S, y, O, null, b, x, _, R, !0) } }, ot = (c, a, h, b, x) => { if (a !== h) { if (a !== k) for (const _ in a) !It(_) && !(_ in h) && s(c, _, a[_], null, x, b); for (const _ in h) { if (It(_)) continue; const R = h[_], E = a[_]; R !== E && _ !== "value" && s(c, _, E, R, x, b) } "value" in h && s(c, "value", a.value, h.value, x) } }, vt = (c, a, h, b, x, _, R, E, S) => { const y = a.el = c ? c.el : o(""), O = a.anchor = c ? c.anchor : o(""); let { patchFlag: A, dynamicChildren: F, slotScopeIds: L } = a; L && (E = E ? E.concat(L) : L), c == null ? (i(y, h, b), i(O, h, b), Le(a.children || [], h, O, x, _, R, E, S)) : A > 0 && A & 64 && F && c.dynamicChildren ? (je(c.dynamicChildren, F, h, x, _, R, E), (a.key != null || x && a === x.subTree) && Dn(c, a, !0)) : Y(c, a, h, O, x, _, R, E, S) }, _t = (c, a, h, b, x, _, R, E, S) => { a.slotScopeIds = E, c == null ? a.shapeFlag & 512 ? x.ctx.activate(a, h, b, R, S) : le(a, h, b, x, _, R, S) : ce(c, a, S) }, le = (c, a, h, b, x, _, R) => { const E = c.component = Lo(c, b, x); if (pn(c) && (E.ctx.renderer = De), No(E, !1, R), E.asyncDep) { if (x && x.registerDep(E, I, R), !c.el) { const S = E.subTree = Xe(wt); H(null, S, a, h), c.placeholder = S.el } } else I(E, c, a, h, x, _, R) }, ce = (c, a, h) => { const b = a.component = c.component; if (So(c, a, h)) if (b.asyncDep && !b.asyncResolved) { J(b, a, h); return } else b.next = a, b.update(); else a.el = c.el, b.vnode = a }, I = (c, a, h, b, x, _, R) => { const E = () => { if (c.isMounted) { let { next: A, bu: F, u: L, parent: X, vnode: q } = c; { const xe = Cn(c); if (xe) { A && (A.el = q.el, J(c, A, R)), xe.asyncDep.then(() => { c.isUnmounted || E() }); return } } let j = A, ue; at(c, !1), A ? (A.el = q.el, J(c, A, R)) : A = q, F && xr(F), (ue = A.props && A.props.onVnodeBeforeUpdate) && Ue(ue, X, A, q), at(c, !0); const oe = yi(c), Ce = c.subTree; c.subTree = oe, N(Ce, oe, m(Ce.el), Ae(Ce), c, x, _), A.el = oe.el, j === null && Eo(c, oe.el), L && Ee(L, x), (ue = A.props && A.props.onVnodeUpdated) && Ee(() => Ue(ue, X, A, q), x) } else { let A; const { el: F, props: L } = a, { bm: X, m: q, parent: j, root: ue, type: oe } = c, Ce = Bt(a); at(c, !1), X && xr(X), !Ce && (A = L && L.onVnodeBeforeMount) && Ue(A, j, a), at(c, !0); { ue.ce && ue.ce._def.shadowRoot !== !1 && ue.ce._injectChildStyle(oe); const xe = c.subTree = yi(c); N(null, xe, h, b, c, x, _), a.el = xe.el } if (q && Ee(q, x), !Ce && (A = L && L.onVnodeMounted)) { const xe = a; Ee(() => Ue(A, j, xe), x) } (a.shapeFlag & 256 || j && Bt(j.vnode) && j.vnode.shapeFlag & 256) && c.a && Ee(c.a, x), c.isMounted = !0, a = h = b = null } }; c.scope.on(); const S = c.effect = new $i(E); c.scope.off(); const y = c.update = S.run.bind(S), O = c.job = S.runIfDirty.bind(S); O.i = c, O.id = c.uid, S.scheduler = () => kr(O), at(c, !0), y() }, J = (c, a, h) => { a.component = c; const b = c.vnode.props; c.vnode = a, c.next = null, oo(c, a.props, b, h), uo(c, a.children, h), Ze(), pi(c), Qe() }, Y = (c, a, h, b, x, _, R, E, S = !1) => { const y = c && c.children, O = c ? c.shapeFlag : 0, A = a.children, { patchFlag: F, shapeFlag: L } = a; if (F > 0) { if (F & 128) { et(y, A, h, b, x, _, R, E, S); return } else if (F & 256) { fe(y, A, h, b, x, _, R, E, S); return } } L & 8 ? (O & 16 && se(y, x, _), A !== y && d(h, A)) : O & 16 ? L & 16 ? et(y, A, h, b, x, _, R, E, S) : se(y, x, _, !0) : (O & 8 && d(h, ""), L & 16 && Le(A, h, b, x, _, R, E, S)) }, fe = (c, a, h, b, x, _, R, E, S) => { c = c || Tt, a = a || Tt; const y = c.length, O = a.length, A = Math.min(y, O); let F; for (F = 0; F < A; F++) { const L = a[F] = S ? rt(a[F]) : He(a[F]); N(c[F], L, h, null, x, _, R, E, S) } y > O ? se(c, x, _, !0, !1, A) : Le(a, h, b, x, _, R, E, S, A) }, et = (c, a, h, b, x, _, R, E, S) => { let y = 0; const O = a.length; let A = c.length - 1, F = O - 1; for (; y <= A && y <= F;) { const L = c[y], X = a[y] = S ? rt(a[y]) : He(a[y]); if (Ft(L, X)) N(L, X, h, null, x, _, R, E, S); else break; y++ } for (; y <= A && y <= F;) { const L = c[A], X = a[F] = S ? rt(a[F]) : He(a[F]); if (Ft(L, X)) N(L, X, h, null, x, _, R, E, S); else break; A--, F-- } if (y > A) { if (y <= F) { const L = F + 1, X = L < O ? a[L].el : b; for (; y <= F;)N(null, a[y] = S ? rt(a[y]) : He(a[y]), h, X, x, _, R, E, S), y++ } } else if (y > F) for (; y <= A;)Z(c[y], x, _, !0), y++; else { const L = y, X = y, q = new Map; for (y = X; y <= F; y++) { const pe = a[y] = S ? rt(a[y]) : He(a[y]); pe.key != null && q.set(pe.key, y) } let j, ue = 0; const oe = F - X + 1; let Ce = !1, xe = 0; const Ye = new Array(oe); for (y = 0; y < oe; y++)Ye[y] = 0; for (y = L; y <= A; y++) { const pe = c[y]; if (ue >= oe) { Z(pe, x, _, !0); continue } let Fe; if (pe.key != null) Fe = q.get(pe.key); else for (j = X; j <= F; j++)if (Ye[j - X] === 0 && Ft(pe, a[j])) { Fe = j; break } Fe === void 0 ? Z(pe, x, _, !0) : (Ye[Fe - X] = y + 1, Fe >= xe ? xe = Fe : Ce = !0, N(pe, a[Fe], h, null, x, _, R, E, S), ue++) } const Jt = Ce ? go(Ye) : Tt; for (j = Jt.length - 1, y = oe - 1; y >= 0; y--) { const pe = X + y, Fe = a[pe], ft = a[pe + 1], Zt = pe + 1 < O ? ft.el || ft.placeholder : b; Ye[y] === 0 ? N(null, Fe, h, Zt, x, _, R, E, S) : Ce && (j < 0 || y !== Jt[j] ? Se(Fe, h, Zt, 2) : j--) } } }, Se = (c, a, h, b, x = null) => { const { el: _, type: R, transition: E, children: S, shapeFlag: y } = c; if (y & 6) { Se(c.component.subTree, a, h, b); return } if (y & 128) { c.suspense.move(a, h, b); return } if (y & 64) { R.move(c, a, h, De); return } if (R === Be) { i(_, a, h); for (let A = 0; A < S.length; A++)Se(S[A], a, h, b); i(c.anchor, a, h); return } if (R === rr) { U(c, a, h); return } if (b !== 2 && y & 1 && E) if (b === 0) E.beforeEnter(_), i(_, a, h), Ee(() => E.enter(_), x); else { const { leave: A, delayLeave: F, afterLeave: L } = E, X = () => { c.ctx.isUnmounted ? n(_) : i(_, a, h) }, q = () => { _._isLeaving && _[Ns](!0), A(_, () => { X(), L && L() }) }; F ? F(_, X, q) : q() } else i(_, a, h) }, Z = (c, a, h, b = !1, x = !1) => { const { type: _, props: R, ref: E, children: S, dynamicChildren: y, shapeFlag: O, patchFlag: A, dirs: F, cacheIndex: L } = c; if (A === -2 && (x = !1), E != null && (Ze(), Nt(E, null, h, c, !0), Qe()), L != null && (a.renderCache[L] = void 0), O & 256) { a.ctx.deactivate(c); return } const X = O & 1 && F, q = !Bt(c); let j; if (q && (j = R && R.onVnodeBeforeUnmount) && Ue(j, a, c), O & 6) ct(c.component, h, b); else { if (O & 128) { c.suspense.unmount(h, b); return } X && ut(c, null, a, "beforeUnmount"), O & 64 ? c.type.remove(c, a, h, De, b) : y && !y.hasOnce && (_ !== Be || A > 0 && A & 64) ? se(y, a, h, !1, !0) : (_ === Be && A & 384 || !x && O & 16) && se(S, a, h), b && ee(c) } (q && (j = R && R.onVnodeUnmounted) || X) && Ee(() => { j && Ue(j, a, c), X && ut(c, null, a, "unmounted") }, h) }, ee = c => { const { type: a, el: h, anchor: b, transition: x } = c; if (a === Be) { lt(h, b); return } if (a === rr) { M(c); return } const _ = () => { n(h), x && !x.persisted && x.afterLeave && x.afterLeave() }; if (c.shapeFlag & 1 && x && !x.persisted) { const { leave: R, delayLeave: E } = x, S = () => R(h, _); E ? E(c.el, _, S) : S() } else _() }, lt = (c, a) => { let h; for (; c !== a;)h = w(c), n(c), c = h; n(a) }, ct = (c, a, h) => { const { bum: b, scope: x, job: _, subTree: R, um: E, m: S, a: y } = c; bi(S), bi(y), b && xr(b), x.stop(), _ && (_.flags |= 8, Z(R, c, a, h)), E && Ee(E, a), Ee(() => { c.isUnmounted = !0 }, a) }, se = (c, a, h, b = !1, x = !1, _ = 0) => { for (let R = _; R < c.length; R++)Z(c[R], a, h, b, x) }, Ae = c => { if (c.shapeFlag & 6) return Ae(c.component.subTree); if (c.shapeFlag & 128) return c.suspense.next(); const a = w(c.anchor || c.el), h = a && a[Ls]; return h ? w(h) : a }; let Pe = !1; const Ge = (c, a, h) => { c == null ? a._vnode && Z(a._vnode, null, null, !0) : N(a._vnode || null, c, a, null, null, null, h), a._vnode = c, Pe || (Pe = !0, pi(), fn(), Pe = !1) }, De = { p: N, um: Z, m: Se, r: ee, mt: le, mc: Le, pc: Y, pbc: je, n: Ae, o: e }; return { render: Ge, hydrate: void 0, createApp: io(Ge) } } function Er({ type: e, props: t }, r) { return r === "svg" && e === "foreignObject" || r === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : r } function at({ effect: e, job: t }, r) { r ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function po(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function Dn(e, t, r = !1) { const i = e.children, n = t.children; if (V(i) && V(n)) for (let s = 0; s < i.length; s++) { const l = i[s]; let o = n[s]; o.shapeFlag & 1 && !o.dynamicChildren && ((o.patchFlag <= 0 || o.patchFlag === 32) && (o = n[s] = rt(n[s]), o.el = l.el), !r && o.patchFlag !== -2 && Dn(l, o)), o.type === vr && o.patchFlag !== -1 && (o.el = l.el), o.type === wt && !o.el && (o.el = l.el) } } function go(e) { const t = e.slice(), r = [0]; let i, n, s, l, o; const u = e.length; for (i = 0; i < u; i++) { const v = e[i]; if (v !== 0) { if (n = r[r.length - 1], e[n] < v) { t[i] = n, r.push(i); continue } for (s = 0, l = r.length - 1; s < l;)o = s + l >> 1, e[r[o]] < v ? s = o + 1 : l = o; v < e[r[s]] && (s > 0 && (t[i] = r[s - 1]), r[s] = i) } } for (s = r.length, l = r[s - 1]; s-- > 0;)r[s] = l, l = t[l]; return r } function Cn(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : Cn(t) } function bi(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const mo = Symbol.for("v-scx"), vo = () => tr(mo); function Rt(e, t, r) { return Fn(e, t, r) } function Fn(e, t, r = k) { const { immediate: i, deep: n, flush: s, once: l } = r, o = he({}, r), u = t && i || !t && s !== "post"; let v; if (Gt) { if (s === "sync") { const C = vo(); v = C.__watcherHandles || (C.__watcherHandles = []) } else if (!u) { const C = () => { }; return C.stop = Ve, C.resume = Ve, C.pause = Ve, C } } const d = _e; o.call = (C, P, N) => $e(C, d, P, N); let m = !1; s === "post" ? o.scheduler = C => { Ee(C, d && d.suspense) } : s !== "sync" && (m = !0, o.scheduler = (C, P) => { P ? C() : kr(C) }), o.augmentJob = C => { t && (C.flags |= 4), m && (C.flags |= 2, d && (C.id = d.uid, C.i = d)) }; const w = Cs(e, t, o); return Gt && (v ? v.push(w) : u && w()), w } function _o(e, t, r) { const i = this.proxy, n = ne(e) ? e.includes(".") ? Pn(i, e) : () => i[e] : e.bind(i, i); let s; z(t) ? s = t : (s = t.handler, r = t); const l = Kt(this), o = Fn(n, s.bind(i), r); return l(), o } function Pn(e, t) { const r = t.split("."); return () => { let i = e; for (let n = 0; n < r.length && i; n++)i = i[r[n]]; return i } } const xo = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${st(t)}Modifiers`] || e[`${gt(t)}Modifiers`]; function bo(e, t, ...r) { if (e.isUnmounted) return; const i = e.vnode.props || k; let n = r; const s = t.startsWith("update:"), l = s && xo(i, t.slice(7)); l && (l.trim && (n = r.map(d => ne(d) ? d.trim() : d)), l.number && (n = r.map(Kn))); let o, u = i[o = _r(t)] || i[o = _r(st(t))]; !u && s && (u = i[o = _r(gt(t))]), u && $e(u, e, 6, n); const v = i[o + "Once"]; if (v) { if (!e.emitted) e.emitted = {}; else if (e.emitted[o]) return; e.emitted[o] = !0, $e(v, e, 6, n) } } function On(e, t, r = !1) { const i = t.emitsCache, n = i.get(e); if (n !== void 0) return n; const s = e.emits; let l = {}, o = !1; if (!z(e)) { const u = v => { const d = On(v, t, !0); d && (o = !0, he(l, d)) }; !r && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u) } return !s && !o ? (ie(e) && i.set(e, null), null) : (V(s) ? s.forEach(u => l[u] = null) : he(l, s), ie(e) && i.set(e, l), l) } function mr(e, t) { return !e || !ur(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), K(e, t[0].toLowerCase() + t.slice(1)) || K(e, gt(t)) || K(e, t)) } function yi(e) { const { type: t, vnode: r, proxy: i, withProxy: n, propsOptions: [s], slots: l, attrs: o, emit: u, render: v, renderCache: d, props: m, data: w, setupState: C, ctx: P, inheritAttrs: N } = e, te = lr(e); let H, G; try { if (r.shapeFlag & 4) { const M = n || i, re = M; H = He(v.call(re, M, d, m, C, w, P)), G = o } else { const M = t; H = He(M.length > 1 ? M(m, { attrs: o, slots: l, emit: u }) : M(m, null)), G = t.props ? o : yo(o) } } catch (M) { zt.length = 0, pr(M, e, 1), H = Xe(wt) } let U = H; if (G && N !== !1) { const M = Object.keys(G), { shapeFlag: re } = U; M.length && re & 7 && (s && M.some(Hr) && (G = To(G, s)), U = At(U, G, !1, !0)) } return r.dirs && (U = At(U, null, !1, !0), U.dirs = U.dirs ? U.dirs.concat(r.dirs) : r.dirs), r.transition && ei(U, r.transition), H = U, lr(te), H } const yo = e => { let t; for (const r in e) (r === "class" || r === "style" || ur(r)) && ((t || (t = {}))[r] = e[r]); return t }, To = (e, t) => { const r = {}; for (const i in e) (!Hr(i) || !(i.slice(9) in t)) && (r[i] = e[i]); return r }; function So(e, t, r) { const { props: i, children: n, component: s } = e, { props: l, children: o, patchFlag: u } = t, v = s.emitsOptions; if (t.dirs || t.transition) return !0; if (r && u >= 0) { if (u & 1024) return !0; if (u & 16) return i ? Ti(i, l, v) : !!l; if (u & 8) { const d = t.dynamicProps; for (let m = 0; m < d.length; m++) { const w = d[m]; if (l[w] !== i[w] && !mr(v, w)) return !0 } } } else return (n || o) && (!o || !o.$stable) ? !0 : i === l ? !1 : i ? l ? Ti(i, l, v) : !0 : !!l; return !1 } function Ti(e, t, r) { const i = Object.keys(t); if (i.length !== Object.keys(e).length) return !0; for (let n = 0; n < i.length; n++) { const s = i[n]; if (t[s] !== e[s] && !mr(r, s)) return !0 } return !1 } function Eo({ vnode: e, parent: t }, r) { for (; t;) { const i = t.subTree; if (i.suspense && i.suspense.activeBranch === e && (i.el = e.el), i === e) (e = t.vnode).el = r, t = t.parent; else break } } const In = e => e.__isSuspense; function Ro(e, t) { t && t.pendingBranch ? V(e) ? t.effects.push(...e) : t.effects.push(e) : Is(e) } const Be = Symbol.for("v-fgt"), vr = Symbol.for("v-txt"), wt = Symbol.for("v-cmt"), rr = Symbol.for("v-stc"), zt = []; let Re = null; function ni(e = !1) { zt.push(Re = e ? null : []) } function wo() { zt.pop(), Re = zt[zt.length - 1] || null } let jt = 1; function Si(e, t = !1) { jt += e, e < 0 && Re && t && (Re.hasOnce = !0) } function Ao(e) { return e.dynamicChildren = jt > 0 ? Re || Tt : null, wo(), jt > 0 && Re && Re.push(e), e } function si(e, t, r, i, n, s) { return Ao(oi(e, t, r, i, n, s, !0)) } function Mn(e) { return e ? e.__v_isVNode === !0 : !1 } function Ft(e, t) { return e.type === t.type && e.key === t.key } const Ln = ({ key: e }) => e ?? null, ir = ({ ref: e, ref_key: t, ref_for: r }) => (typeof e == "number" && (e = "" + e), e != null ? ne(e) || de(e) || z(e) ? { i: ze, r: e, k: t, f: !!r } : e : null); function oi(e, t = null, r = null, i = 0, n = null, s = e === Be ? 0 : 1, l = !1, o = !1) { const u = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && Ln(t), ref: t && ir(t), scopeId: an, slotScopeIds: null, children: r, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: s, patchFlag: i, dynamicProps: n, dynamicChildren: null, appContext: null, ctx: ze }; return o ? (li(u, r), s & 128 && e.normalize(u)) : r && (u.shapeFlag |= ne(r) ? 8 : 16), jt > 0 && !l && Re && (u.patchFlag > 0 || s & 6) && u.patchFlag !== 32 && Re.push(u), u } const Xe = Do; function Do(e, t = null, r = null, i = 0, n = null, s = !1) { if ((!e || e === qs) && (e = wt), Mn(e)) { const o = At(e, t, !0); return r && li(o, r), jt > 0 && !s && Re && (o.shapeFlag & 6 ? Re[Re.indexOf(e)] = o : Re.push(o)), o.patchFlag = -2, o } if (Vo(e) && (e = e.__vccOpts), t) { t = Co(t); let { class: o, style: u } = t; o && !ne(o) && (t.class = Yt(o)), ie(u) && (Zr(u) && !V(u) && (u = he({}, u)), t.style = Xr(u)) } const l = ne(e) ? 1 : In(e) ? 128 : Us(e) ? 64 : ie(e) ? 4 : z(e) ? 2 : 0; return oi(e, t, r, i, n, l, s, !0) } function Co(e) { return e ? Zr(e) || Tn(e) ? he({}, e) : e : null } function At(e, t, r = !1, i = !1) { const { props: n, ref: s, patchFlag: l, children: o, transition: u } = e, v = t ? Oo(n || {}, t) : n, d = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: v, key: v && Ln(v), ref: t && t.ref ? r && s ? V(s) ? s.concat(ir(t)) : [s, ir(t)] : ir(t) : s, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: o, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== Be ? l === -1 ? 16 : l | 16 : l, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: u, component: e.component, suspense: e.suspense, ssContent: e.ssContent && At(e.ssContent), ssFallback: e.ssFallback && At(e.ssFallback), placeholder: e.placeholder, el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return u && i && ei(d, u.clone(d)), d } function Fo(e = " ", t = 0) { return Xe(vr, null, e, t) } function Po(e, t) { const r = Xe(rr, null, e); return r.staticCount = t, r } function He(e) { return e == null || typeof e == "boolean" ? Xe(wt) : V(e) ? Xe(Be, null, e.slice()) : Mn(e) ? rt(e) : Xe(vr, null, String(e)) } function rt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : At(e) } function li(e, t) { let r = 0; const { shapeFlag: i } = e; if (t == null) t = null; else if (V(t)) r = 16; else if (typeof t == "object") if (i & 65) { const n = t.default; n && (n._c && (n._d = !1), li(e, n()), n._c && (n._d = !0)); return } else { r = 32; const n = t._; !n && !Tn(t) ? t._ctx = ze : n === 3 && ze && (ze.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else z(t) ? (t = { default: t, _ctx: ze }, r = 32) : (t = String(t), i & 64 ? (r = 16, t = [Fo(t)]) : r = 8); e.children = t, e.shapeFlag |= r } function Oo(...e) { const t = {}; for (let r = 0; r < e.length; r++) { const i = e[r]; for (const n in i) if (n === "class") t.class !== i.class && (t.class = Yt([t.class, i.class])); else if (n === "style") t.style = Xr([t.style, i.style]); else if (ur(n)) { const s = t[n], l = i[n]; l && s !== l && !(V(s) && s.includes(l)) && (t[n] = s ? [].concat(s, l) : l) } else n !== "" && (t[n] = i[n]) } return t } function Ue(e, t, r, i = null) { $e(e, t, 7, [r, i]) } const Io = xn(); let Mo = 0; function Lo(e, t, r) { const i = e.type, n = (t ? t.appContext : e.appContext) || Io, s = { uid: Mo++, vnode: e, type: i, parent: t, appContext: n, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new ts(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(n.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: En(i, n), emitsOptions: On(i, n), emit: null, emitted: null, propsDefaults: k, inheritAttrs: i.inheritAttrs, ctx: k, data: k, props: k, attrs: k, slots: k, refs: k, setupState: k, setupContext: null, suspense: r, suspenseId: r ? r.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return s.ctx = { _: s }, s.root = t ? t.root : s, s.emit = bo.bind(null, s), e.ce && e.ce(s), s } let _e = null; const Uo = () => _e || ze; let fr, Ur; { const e = hr(), t = (r, i) => { let n; return (n = e[r]) || (n = e[r] = []), n.push(i), s => { n.length > 1 ? n.forEach(l => l(s)) : n[0](s) } }; fr = t("__VUE_INSTANCE_SETTERS__", r => _e = r), Ur = t("__VUE_SSR_SETTERS__", r => Gt = r) } const Kt = e => { const t = _e; return fr(e), e.scope.on(), () => { e.scope.off(), fr(t) } }, Ei = () => { _e && _e.scope.off(), fr(null) }; function Un(e) { return e.vnode.shapeFlag & 4 } let Gt = !1; function No(e, t = !1, r = !1) { t && Ur(t); const { props: i, children: n } = e.vnode, s = Un(e); so(e, i, s, t), fo(e, n, r || t); const l = s ? Bo(e, t) : void 0; return t && Ur(!1), l } function Bo(e, t) { const r = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Js); const { setup: i } = r; if (i) { Ze(); const n = e.setupContext = i.length > 1 ? zo(e) : null, s = Kt(e), l = Wt(i, e, 0, [e.props, n]), o = Hi(l); if (Qe(), s(), (o || e.sp) && !Bt(e) && hn(e), o) { if (l.then(Ei, Ei), t) return l.then(u => { Ri(e, u) }).catch(u => { pr(u, e, 0) }); e.asyncDep = l } else Ri(e, l) } else Nn(e) } function Ri(e, t, r) { z(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : ie(t) && (e.setupState = on(t)), Nn(e) } function Nn(e, t, r) { const i = e.type; e.render || (e.render = i.render || Ve); { const n = Kt(e); Ze(); try { Zs(e) } finally { Qe(), n() } } } const Ho = { get(e, t) { return ae(e, "get", ""), e[t] } }; function zo(e) { const t = r => { e.exposed = r || {} }; return { attrs: new Proxy(e.attrs, Ho), slots: e.slots, emit: e.emit, expose: t } } function ci(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(on(Ts(e.exposed)), { get(t, r) { if (r in t) return t[r]; if (r in Ht) return Ht[r](e) }, has(t, r) { return r in t || r in Ht } })) : e.proxy } function Vo(e) { return z(e) && "__vccOpts" in e } const Xo = (e, t) => As(e, t, Gt), $o = "3.5.20";/**
* @vue/runtime-dom v3.5.20
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Nr; const wi = typeof window < "u" && window.trustedTypes; if (wi) try { Nr = wi.createPolicy("vue", { createHTML: e => e }) } catch { } const Bn = Nr ? e => Nr.createHTML(e) : e => e, jo = "http://www.w3.org/2000/svg", Go = "http://www.w3.org/1998/Math/MathML", qe = typeof document < "u" ? document : null, Ai = qe && qe.createElement("template"), Yo = { insert: (e, t, r) => { t.insertBefore(e, r || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, r, i) => { const n = t === "svg" ? qe.createElementNS(jo, e) : t === "mathml" ? qe.createElementNS(Go, e) : r ? qe.createElement(e, { is: r }) : qe.createElement(e); return e === "select" && i && i.multiple != null && n.setAttribute("multiple", i.multiple), n }, createText: e => qe.createTextNode(e), createComment: e => qe.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => qe.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, r, i, n, s) { const l = r ? r.previousSibling : t.lastChild; if (n && (n === s || n.nextSibling)) for (; t.insertBefore(n.cloneNode(!0), r), !(n === s || !(n = n.nextSibling));); else { Ai.innerHTML = Bn(i === "svg" ? `<svg>${e}</svg>` : i === "mathml" ? `<math>${e}</math>` : e); const o = Ai.content; if (i === "svg" || i === "mathml") { const u = o.firstChild; for (; u.firstChild;)o.appendChild(u.firstChild); o.removeChild(u) } t.insertBefore(o, r) } return [l ? l.nextSibling : t.firstChild, r ? r.previousSibling : t.lastChild] } }, Wo = Symbol("_vtc"); function Ko(e, t, r) { const i = e[Wo]; i && (t = (t ? [t, ...i] : [...i]).join(" ")), t == null ? e.removeAttribute("class") : r ? e.setAttribute("class", t) : e.className = t } const Di = Symbol("_vod"), qo = Symbol("_vsh"), Jo = Symbol(""), Zo = /(^|;)\s*display\s*:/; function Qo(e, t, r) { const i = e.style, n = ne(r); let s = !1; if (r && !n) { if (t) if (ne(t)) for (const l of t.split(";")) { const o = l.slice(0, l.indexOf(":")).trim(); r[o] == null && nr(i, o, "") } else for (const l in t) r[l] == null && nr(i, l, ""); for (const l in r) l === "display" && (s = !0), nr(i, l, r[l]) } else if (n) { if (t !== r) { const l = i[Jo]; l && (r += ";" + l), i.cssText = r, s = Zo.test(r) } } else t && e.removeAttribute("style"); Di in e && (e[Di] = s ? i.display : "", e[qo] && (i.display = "none")) } const Ci = /\s*!important$/; function nr(e, t, r) { if (V(r)) r.forEach(i => nr(e, t, i)); else if (r == null && (r = ""), t.startsWith("--")) e.setProperty(t, r); else { const i = ko(e, t); Ci.test(r) ? e.setProperty(gt(i), r.replace(Ci, ""), "important") : e[i] = r } } const Fi = ["Webkit", "Moz", "ms"], Rr = {}; function ko(e, t) { const r = Rr[t]; if (r) return r; let i = st(t); if (i !== "filter" && i in e) return Rr[t] = i; i = zi(i); for (let n = 0; n < Fi.length; n++) { const s = Fi[n] + i; if (s in e) return Rr[t] = s } return t } const Pi = "http://www.w3.org/1999/xlink"; function Oi(e, t, r, i, n, s = es(t)) { i && t.startsWith("xlink:") ? r == null ? e.removeAttributeNS(Pi, t.slice(6, t.length)) : e.setAttributeNS(Pi, t, r) : r == null || s && !Xi(r) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : Dt(r) ? String(r) : r) } function Ii(e, t, r, i, n) { if (t === "innerHTML" || t === "textContent") { r != null && (e[t] = t === "innerHTML" ? Bn(r) : r); return } const s = e.tagName; if (t === "value" && s !== "PROGRESS" && !s.includes("-")) { const o = s === "OPTION" ? e.getAttribute("value") || "" : e.value, u = r == null ? e.type === "checkbox" ? "on" : "" : String(r); (o !== u || !("_value" in e)) && (e.value = u), r == null && e.removeAttribute(t), e._value = r; return } let l = !1; if (r === "" || r == null) { const o = typeof e[t]; o === "boolean" ? r = Xi(r) : r == null && o === "string" ? (r = "", l = !0) : o === "number" && (r = 0, l = !0) } try { e[t] = r } catch { } l && e.removeAttribute(n || t) } function el(e, t, r, i) { e.addEventListener(t, r, i) } function tl(e, t, r, i) { e.removeEventListener(t, r, i) } const Mi = Symbol("_vei"); function rl(e, t, r, i, n = null) { const s = e[Mi] || (e[Mi] = {}), l = s[t]; if (i && l) l.value = i; else { const [o, u] = il(t); if (i) { const v = s[t] = ol(i, n); el(e, o, v, u) } else l && (tl(e, o, l, u), s[t] = void 0) } } const Li = /(?:Once|Passive|Capture)$/; function il(e) { let t; if (Li.test(e)) { t = {}; let i; for (; i = e.match(Li);)e = e.slice(0, e.length - i[0].length), t[i[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : gt(e.slice(2)), t] } let wr = 0; const nl = Promise.resolve(), sl = () => wr || (nl.then(() => wr = 0), wr = Date.now()); function ol(e, t) { const r = i => { if (!i._vts) i._vts = Date.now(); else if (i._vts <= r.attached) return; $e(ll(i, r.value), t, 5, [i]) }; return r.value = e, r.attached = sl(), r } function ll(e, t) { if (V(t)) { const r = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { r.call(e), e._stopped = !0 }, t.map(i => n => !n._stopped && i && i(n)) } else return t } const Ui = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, cl = (e, t, r, i, n, s) => { const l = n === "svg"; t === "class" ? Ko(e, i, l) : t === "style" ? Qo(e, r, i) : ur(t) ? Hr(t) || rl(e, t, r, i, s) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : fl(e, t, i, l)) ? (Ii(e, t, i), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && Oi(e, t, i, l, s, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !ne(i)) ? Ii(e, st(t), i, s, t) : (t === "true-value" ? e._trueValue = i : t === "false-value" && (e._falseValue = i), Oi(e, t, i, l)) }; function fl(e, t, r, i) { if (i) return !!(t === "innerHTML" || t === "textContent" || t in e && Ui(t) && z(r)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const n = e.tagName; if (n === "IMG" || n === "VIDEO" || n === "CANVAS" || n === "SOURCE") return !1 } return Ui(t) && ne(r) ? !1 : t in e } const ul = he({ patchProp: cl }, Yo); let Ni; function al() { return Ni || (Ni = ao(ul)) } const dl = ((...e) => { const t = al().createApp(...e), { mount: r } = t; return t.mount = i => { const n = pl(i); if (!n) return; const s = t._component; !z(s) && !s.render && !s.template && (s.template = n.innerHTML), n.nodeType === 1 && (n.textContent = ""); const l = r(n, !1, hl(n)); return n instanceof Element && (n.removeAttribute("v-cloak"), n.setAttribute("data-v-app", "")), l }, t }); function hl(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function pl(e) { return ne(e) ? document.querySelector(e) : e } function Hn(...e) { return e.filter(Boolean).join(" ") } const gl = dn({
        __name: "FluidCursor", props: { simResolution: { default: 128 }, dyeResolution: { default: 1440 }, captureResolution: { default: 512 }, densityDissipation: { default: 3.5 }, velocityDissipation: { default: 2 }, pressure: { default: .1 }, pressureIterations: { default: 20 }, curl: { default: 3 }, splatRadius: { default: .2 }, splatForce: { default: 6e3 }, shading: { type: Boolean, default: !0 }, colorUpdateSpeed: { default: 10 }, backColor: { default: () => ({ r: .5, g: 0, b: 0 }) }, transparent: { type: Boolean, default: !0 }, class: {} }, setup(e) {
          const t = e; function r() { return { id: -1, texcoordX: 0, texcoordY: 0, prevTexcoordX: 0, prevTexcoordY: 0, deltaX: 0, deltaY: 0, down: !1, moved: !1, color: { r: 0, g: 0, b: 0 } } } const i = sn(null); return ti(() => {
            const n = i.value; if (!n) return; const s = [r()], l = { SIM_RESOLUTION: t.simResolution, DYE_RESOLUTION: t.dyeResolution, CAPTURE_RESOLUTION: t.captureResolution, DENSITY_DISSIPATION: t.densityDissipation, VELOCITY_DISSIPATION: t.velocityDissipation, PRESSURE: t.pressure, PRESSURE_ITERATIONS: t.pressureIterations, CURL: t.curl, SPLAT_RADIUS: t.splatRadius, SPLAT_FORCE: t.splatForce, SHADING: t.shading, COLOR_UPDATE_SPEED: t.colorUpdateSpeed, BACK_COLOR: t.backColor, TRANSPARENT: t.transparent }, { gl: o, ext: u } = v(n); if (!o || !u) return; u.supportLinearFiltering || (l.DYE_RESOLUTION = 256, l.SHADING = !1); function v(f) { const p = { alpha: !0, depth: !1, stencil: !1, antialias: !1, preserveDrawingBuffer: !1 }; let g = f.getContext("webgl2", p); if (g || (g = f.getContext("webgl", p) || f.getContext("experimental-webgl", p)), !g) throw new Error("Unable to initialize WebGL."); const T = "drawBuffers" in g; let D = !1, B = null; T ? (g.getExtension("EXT_color_buffer_float"), D = !!g.getExtension("OES_texture_float_linear")) : (B = g.getExtension("OES_texture_half_float"), D = !!g.getExtension("OES_texture_half_float_linear")), g.clearColor(0, 0, 0, 1); const $ = T ? g.HALF_FLOAT : B && B.HALF_FLOAT_OES || 0; let be, ye, We; return T ? (be = d(g, g.RGBA16F, g.RGBA, $), ye = d(g, g.RG16F, g.RG, $), We = d(g, g.R16F, g.RED, $)) : (be = d(g, g.RGBA, g.RGBA, $), ye = d(g, g.RGBA, g.RGBA, $), We = d(g, g.RGBA, g.RGBA, $)), { gl: g, ext: { formatRGBA: be, formatRG: ye, formatR: We, halfFloatTexType: $, supportLinearFiltering: D } } } function d(f, p, g, T) { if (!m(f, p, g, T)) { if ("drawBuffers" in f) { const D = f; switch (p) { case D.R16F: return d(D, D.RG16F, D.RG, T); case D.RG16F: return d(D, D.RGBA16F, D.RGBA, T); default: return null } } return null } return { internalFormat: p, format: g } } function m(f, p, g, T) { const D = f.createTexture(); if (!D) return !1; f.bindTexture(f.TEXTURE_2D, D), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texImage2D(f.TEXTURE_2D, 0, p, 4, 4, 0, g, T, null); const B = f.createFramebuffer(); return B ? (f.bindFramebuffer(f.FRAMEBUFFER, B), f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, D, 0), f.checkFramebufferStatus(f.FRAMEBUFFER) === f.FRAMEBUFFER_COMPLETE) : !1 } function w(f) { if (!f.length) return 0; let p = 0; for (let g = 0; g < f.length; g++)p = (p << 5) - p + f.charCodeAt(g), p |= 0; return p } function C(f, p) {
              if (!p) return f; let g = ""; for (const T of p) g += `#define ${T}
`; return g + f
            } function P(f, p, g = null) { const T = C(p, g), D = o.createShader(f); return D ? (o.shaderSource(D, T), o.compileShader(D), D) : null } function N(f, p) { if (!f || !p) return null; const g = o.createProgram(); return g ? (o.attachShader(g, f), o.attachShader(g, p), o.linkProgram(g), g) : null } function te(f) { const p = {}, g = o.getProgramParameter(f, o.ACTIVE_UNIFORMS); for (let T = 0; T < g; T++) { const D = o.getActiveUniform(f, T); D && (p[D.name] = o.getUniformLocation(f, D.name)) } return p } class H { constructor(p, g) { this.program = N(p, g), this.uniforms = this.program ? te(this.program) : {} } bind() { this.program && o.useProgram(this.program) } } class G { constructor(p, g) { this.vertexShader = p, this.fragmentShaderSource = g, this.programs = {}, this.activeProgram = null, this.uniforms = {} } setKeywords(p) { let g = 0; for (const D of p) g += w(D); let T = this.programs[g]; if (T == null) { const D = P(o.FRAGMENT_SHADER, this.fragmentShaderSource, p); T = N(this.vertexShader, D), this.programs[g] = T } T !== this.activeProgram && (T && (this.uniforms = te(T)), this.activeProgram = T) } bind() { this.activeProgram && o.useProgram(this.activeProgram) } } const U = P(o.VERTEX_SHADER, `
        precision highp float;
        attribute vec2 aPosition;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform vec2 texelSize;
    
        void main () {
          vUv = aPosition * 0.5 + 0.5;
          vL = vUv - vec2(texelSize.x, 0.0);
          vR = vUv + vec2(texelSize.x, 0.0);
          vT = vUv + vec2(0.0, texelSize.y);
          vB = vUv - vec2(0.0, texelSize.y);
          gl_Position = vec4(aPosition, 0.0, 1.0);
        }
      `), M = P(o.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        uniform sampler2D uTexture;
    
        void main () {
          gl_FragColor = texture2D(uTexture, vUv);
        }
      `), re = P(o.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        uniform sampler2D uTexture;
        uniform float value;
    
        void main () {
          gl_FragColor = value * texture2D(uTexture, vUv);
        }
      `), Me = `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform sampler2D uTexture;
        uniform sampler2D uDithering;
        uniform vec2 ditherScale;
        uniform vec2 texelSize;
    
        vec3 linearToGamma (vec3 color) {
          color = max(color, vec3(0));
          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));
        }
    
        void main () {
          vec3 c = texture2D(uTexture, vUv).rgb;
          #ifdef SHADING
            vec3 lc = texture2D(uTexture, vL).rgb;
            vec3 rc = texture2D(uTexture, vR).rgb;
            vec3 tc = texture2D(uTexture, vT).rgb;
            vec3 bc = texture2D(uTexture, vB).rgb;
    
            float dx = length(rc) - length(lc);
            float dy = length(tc) - length(bc);
    
            vec3 n = normalize(vec3(dx, dy, length(texelSize)));
            vec3 l = vec3(0.0, 0.0, 1.0);
    
            float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
            c *= diffuse;
          #endif
    
          float a = max(c.r, max(c.g, c.b));
          gl_FragColor = vec4(c, a);
        }
      `, we = P(o.FRAGMENT_SHADER, `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        uniform sampler2D uTarget;
        uniform float aspectRatio;
        uniform vec3 color;
        uniform vec2 point;
        uniform float radius;
    
        void main () {
          vec2 p = vUv - point.xy;
          p.x *= aspectRatio;
          vec3 splat = exp(-dot(p, p) / radius) * color;
          vec3 base = texture2D(uTarget, vUv).xyz;
          gl_FragColor = vec4(base + splat, 1.0);
        }
      `), Le = P(o.FRAGMENT_SHADER, `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        uniform sampler2D uVelocity;
        uniform sampler2D uSource;
        uniform vec2 texelSize;
        uniform vec2 dyeTexelSize;
        uniform float dt;
        uniform float dissipation;
    
        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
          vec2 st = uv / tsize - 0.5;
          vec2 iuv = floor(st);
          vec2 fuv = fract(st);
    
          vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
          vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
          vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
          vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);
    
          return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
        }
    
        void main () {
          #ifdef MANUAL_FILTERING
            vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
            vec4 result = bilerp(uSource, coord, dyeTexelSize);
          #else
            vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
            vec4 result = texture2D(uSource, coord);
          #endif
          float decay = 1.0 + dissipation * dt;
          gl_FragColor = result / decay;
        }
      `, u.supportLinearFiltering ? null : ["MANUAL_FILTERING"]), mt = P(o.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uVelocity;
    
        void main () {
          float L = texture2D(uVelocity, vL).x;
          float R = texture2D(uVelocity, vR).x;
          float T = texture2D(uVelocity, vT).y;
          float B = texture2D(uVelocity, vB).y;
    
          vec2 C = texture2D(uVelocity, vUv).xy;
          if (vL.x < 0.0) { L = -C.x; }
          if (vR.x > 1.0) { R = -C.x; }
          if (vT.y > 1.0) { T = -C.y; }
          if (vB.y < 0.0) { B = -C.y; }
    
          float div = 0.5 * (R - L + T - B);
          gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
        }
      `), je = P(o.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uVelocity;
    
        void main () {
          float L = texture2D(uVelocity, vL).y;
          float R = texture2D(uVelocity, vR).y;
          float T = texture2D(uVelocity, vT).x;
          float B = texture2D(uVelocity, vB).x;
          float vorticity = R - L - T + B;
          gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
        }
      `), ot = P(o.FRAGMENT_SHADER, `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform sampler2D uVelocity;
        uniform sampler2D uCurl;
        uniform float curl;
        uniform float dt;
    
        void main () {
          float L = texture2D(uCurl, vL).x;
          float R = texture2D(uCurl, vR).x;
          float T = texture2D(uCurl, vT).x;
          float B = texture2D(uCurl, vB).x;
          float C = texture2D(uCurl, vUv).x;
    
          vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
          force /= length(force) + 0.0001;
          force *= curl * C;
          force.y *= -1.0;
    
          vec2 velocity = texture2D(uVelocity, vUv).xy;
          velocity += force * dt;
          velocity = min(max(velocity, -1000.0), 1000.0);
          gl_FragColor = vec4(velocity, 0.0, 1.0);
        }
      `), vt = P(o.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uPressure;
        uniform sampler2D uDivergence;
    
        void main () {
          float L = texture2D(uPressure, vL).x;
          float R = texture2D(uPressure, vR).x;
          float T = texture2D(uPressure, vT).x;
          float B = texture2D(uPressure, vB).x;
          float C = texture2D(uPressure, vUv).x;
          float divergence = texture2D(uDivergence, vUv).x;
          float pressure = (L + R + B + T - divergence) * 0.25;
          gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
        }
      `), _t = P(o.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uPressure;
        uniform sampler2D uVelocity;
    
        void main () {
          float L = texture2D(uPressure, vL).x;
          float R = texture2D(uPressure, vR).x;
          float T = texture2D(uPressure, vT).x;
          float B = texture2D(uPressure, vB).x;
          vec2 velocity = texture2D(uVelocity, vUv).xy;
          velocity.xy -= vec2(R - L, T - B);
          gl_FragColor = vec4(velocity, 0.0, 1.0);
        }
      `), le = (() => { const f = o.createBuffer(); o.bindBuffer(o.ARRAY_BUFFER, f), o.bufferData(o.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), o.STATIC_DRAW); const p = o.createBuffer(); return o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, p), o.bufferData(o.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), o.STATIC_DRAW), o.vertexAttribPointer(0, 2, o.FLOAT, !1, 0, 0), o.enableVertexAttribArray(0), (g, T = !1) => { o && (g ? (o.viewport(0, 0, g.width, g.height), o.bindFramebuffer(o.FRAMEBUFFER, g.fbo)) : (o.viewport(0, 0, o.drawingBufferWidth, o.drawingBufferHeight), o.bindFramebuffer(o.FRAMEBUFFER, null)), T && (o.clearColor(0, 0, 0, 1), o.clear(o.COLOR_BUFFER_BIT)), o.drawElements(o.TRIANGLES, 6, o.UNSIGNED_SHORT, 0)) } })(); let ce, I, J, Y, fe; const et = new H(U, M), Se = new H(U, re), Z = new H(U, we), ee = new H(U, Le), lt = new H(U, mt), ct = new H(U, je), se = new H(U, ot), Ae = new H(U, vt), Pe = new H(U, _t), Ge = new G(U, Me); function De(f, p, g, T, D, B) { o.activeTexture(o.TEXTURE0); const $ = o.createTexture(); o.bindTexture(o.TEXTURE_2D, $), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, B), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, B), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texImage2D(o.TEXTURE_2D, 0, g, f, p, 0, T, D, null); const be = o.createFramebuffer(); o.bindFramebuffer(o.FRAMEBUFFER, be), o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, $, 0), o.viewport(0, 0, f, p), o.clear(o.COLOR_BUFFER_BIT); const ye = 1 / f, We = 1 / p; return { texture: $, fbo: be, width: f, height: p, texelSizeX: ye, texelSizeY: We, attach(xt) { return o.activeTexture(o.TEXTURE0 + xt), o.bindTexture(o.TEXTURE_2D, $), xt } } } function qt(f, p, g, T, D, B) { const $ = De(f, p, g, T, D, B), be = De(f, p, g, T, D, B); return { width: f, height: p, texelSizeX: $.texelSizeX, texelSizeY: $.texelSizeY, read: $, write: be, swap() { const ye = this.read; this.read = this.write, this.write = ye } } } function c(f, p, g, T, D, B, $) { const be = De(p, g, T, D, B, $); return et.bind(), et.uniforms.uTexture && o.uniform1i(et.uniforms.uTexture, f.attach(0)), le(be, !1), be } function a(f, p, g, T, D, B, $) { return f.width === p && f.height === g || (f.read = c(f.read, p, g, T, D, B, $), f.write = De(p, g, T, D, B, $), f.width = p, f.height = g, f.texelSizeX = 1 / p, f.texelSizeY = 1 / g), f } function h() { const f = x(l.SIM_RESOLUTION), p = x(l.DYE_RESOLUTION), g = u.halfFloatTexType, T = u.formatRGBA, D = u.formatRG, B = u.formatR, $ = u.supportLinearFiltering ? o.LINEAR : o.NEAREST; o.disable(o.BLEND), ce ? ce = a(ce, p.width, p.height, T.internalFormat, T.format, g, $) : ce = qt(p.width, p.height, T.internalFormat, T.format, g, $), I ? I = a(I, f.width, f.height, D.internalFormat, D.format, g, $) : I = qt(f.width, f.height, D.internalFormat, D.format, g, $), J = De(f.width, f.height, B.internalFormat, B.format, g, o.NEAREST), Y = De(f.width, f.height, B.internalFormat, B.format, g, o.NEAREST), fe = qt(f.width, f.height, B.internalFormat, B.format, g, o.NEAREST) } function b() { const f = []; l.SHADING && f.push("SHADING"), Ge.setKeywords(f) } function x(f) { const p = o.drawingBufferWidth, g = o.drawingBufferHeight, T = p / g, D = T < 1 ? 1 / T : T, B = Math.round(f), $ = Math.round(f * D); return p > g ? { width: $, height: B } : { width: B, height: $ } } function _(f) { const p = window.devicePixelRatio || 1; return Math.floor(f * p) } b(), h(); let R = Date.now(), E = 0; function S() { const f = y(); O() && h(), A(f), F(), L(f), X(null), requestAnimationFrame(S) } function y() { const f = Date.now(); let p = (f - R) / 1e3; return p = Math.min(p, .016666), R = f, p } function O() { const f = _(n.clientWidth), p = _(n.clientHeight); return n.width !== f || n.height !== p ? (n.width = f, n.height = p, !0) : !1 } function A(f) { E += f * l.COLOR_UPDATE_SPEED, E >= 1 && (E = zn(E, 0, 1), s.forEach(p => { p.color = ft() })) } function F() { for (const f of s) f.moved && (f.moved = !1, j(f)) } function L(f) { o.disable(o.BLEND), ct.bind(), ct.uniforms.texelSize && o.uniform2f(ct.uniforms.texelSize, I.texelSizeX, I.texelSizeY), ct.uniforms.uVelocity && o.uniform1i(ct.uniforms.uVelocity, I.read.attach(0)), le(Y), se.bind(), se.uniforms.texelSize && o.uniform2f(se.uniforms.texelSize, I.texelSizeX, I.texelSizeY), se.uniforms.uVelocity && o.uniform1i(se.uniforms.uVelocity, I.read.attach(0)), se.uniforms.uCurl && o.uniform1i(se.uniforms.uCurl, Y.attach(1)), se.uniforms.curl && o.uniform1f(se.uniforms.curl, l.CURL), se.uniforms.dt && o.uniform1f(se.uniforms.dt, f), le(I.write), I.swap(), lt.bind(), lt.uniforms.texelSize && o.uniform2f(lt.uniforms.texelSize, I.texelSizeX, I.texelSizeY), lt.uniforms.uVelocity && o.uniform1i(lt.uniforms.uVelocity, I.read.attach(0)), le(J), Se.bind(), Se.uniforms.uTexture && o.uniform1i(Se.uniforms.uTexture, fe.read.attach(0)), Se.uniforms.value && o.uniform1f(Se.uniforms.value, l.PRESSURE), le(fe.write), fe.swap(), Ae.bind(), Ae.uniforms.texelSize && o.uniform2f(Ae.uniforms.texelSize, I.texelSizeX, I.texelSizeY), Ae.uniforms.uDivergence && o.uniform1i(Ae.uniforms.uDivergence, J.attach(0)); for (let g = 0; g < l.PRESSURE_ITERATIONS; g++)Ae.uniforms.uPressure && o.uniform1i(Ae.uniforms.uPressure, fe.read.attach(1)), le(fe.write), fe.swap(); Pe.bind(), Pe.uniforms.texelSize && o.uniform2f(Pe.uniforms.texelSize, I.texelSizeX, I.texelSizeY), Pe.uniforms.uPressure && o.uniform1i(Pe.uniforms.uPressure, fe.read.attach(0)), Pe.uniforms.uVelocity && o.uniform1i(Pe.uniforms.uVelocity, I.read.attach(1)), le(I.write), I.swap(), ee.bind(), ee.uniforms.texelSize && o.uniform2f(ee.uniforms.texelSize, I.texelSizeX, I.texelSizeY), !u.supportLinearFiltering && ee.uniforms.dyeTexelSize && o.uniform2f(ee.uniforms.dyeTexelSize, I.texelSizeX, I.texelSizeY); const p = I.read.attach(0); ee.uniforms.uVelocity && o.uniform1i(ee.uniforms.uVelocity, p), ee.uniforms.uSource && o.uniform1i(ee.uniforms.uSource, p), ee.uniforms.dt && o.uniform1f(ee.uniforms.dt, f), ee.uniforms.dissipation && o.uniform1f(ee.uniforms.dissipation, l.VELOCITY_DISSIPATION), le(I.write), I.swap(), !u.supportLinearFiltering && ee.uniforms.dyeTexelSize && o.uniform2f(ee.uniforms.dyeTexelSize, ce.texelSizeX, ce.texelSizeY), ee.uniforms.uVelocity && o.uniform1i(ee.uniforms.uVelocity, I.read.attach(0)), ee.uniforms.uSource && o.uniform1i(ee.uniforms.uSource, ce.read.attach(1)), ee.uniforms.dissipation && o.uniform1f(ee.uniforms.dissipation, l.DENSITY_DISSIPATION), le(ce.write), ce.swap() } function X(f) { o.blendFunc(o.ONE, o.ONE_MINUS_SRC_ALPHA), o.enable(o.BLEND), q(f) } function q(f) { const p = o.drawingBufferWidth, g = o.drawingBufferHeight; Ge.bind(), l.SHADING && Ge.uniforms.texelSize && o.uniform2f(Ge.uniforms.texelSize, 1 / p, 1 / g), Ge.uniforms.uTexture && o.uniform1i(Ge.uniforms.uTexture, ce.read.attach(0)), le(f, !1) } function j(f) { const p = f.deltaX * l.SPLAT_FORCE, g = f.deltaY * l.SPLAT_FORCE; oe(f.texcoordX, f.texcoordY, p, g, f.color) } function ue(f) { const p = ft(); p.r *= 10, p.g *= 10, p.b *= 10; const g = 10 * (Math.random() - .5), T = 30 * (Math.random() - .5); oe(f.texcoordX, f.texcoordY, g, T, p) } function oe(f, p, g, T, D) { Z.bind(), Z.uniforms.uTarget && o.uniform1i(Z.uniforms.uTarget, I.read.attach(0)), Z.uniforms.aspectRatio && o.uniform1f(Z.uniforms.aspectRatio, n.width / n.height), Z.uniforms.point && o.uniform2f(Z.uniforms.point, f, p), Z.uniforms.color && o.uniform3f(Z.uniforms.color, g, T, 0), Z.uniforms.radius && o.uniform1f(Z.uniforms.radius, Ce(l.SPLAT_RADIUS / 100)), le(I.write), I.swap(), Z.uniforms.uTarget && o.uniform1i(Z.uniforms.uTarget, ce.read.attach(0)), Z.uniforms.color && o.uniform3f(Z.uniforms.color, D.r, D.g, D.b), le(ce.write), ce.swap() } function Ce(f) { const p = n.width / n.height; return p > 1 && (f *= p), f } function xe(f, p, g, T) { f.id = p, f.down = !0, f.moved = !1, f.texcoordX = g / n.width, f.texcoordY = 1 - T / n.height, f.prevTexcoordX = f.texcoordX, f.prevTexcoordY = f.texcoordY, f.deltaX = 0, f.deltaY = 0, f.color = ft() } function Ye(f, p, g, T) { f.prevTexcoordX = f.texcoordX, f.prevTexcoordY = f.texcoordY, f.texcoordX = p / n.width, f.texcoordY = 1 - g / n.height, f.deltaX = pe(f.texcoordX - f.prevTexcoordX), f.deltaY = Fe(f.texcoordY - f.prevTexcoordY), f.moved = Math.abs(f.deltaX) > 0 || Math.abs(f.deltaY) > 0, f.color = T } function Jt(f) { f.down = !1 } function pe(f) { const p = n.width / n.height; return p < 1 && (f *= p), f } function Fe(f) { const p = n.width / n.height; return p > 1 && (f /= p), f } function ft() { const f = Zt(Math.random(), 1, 1); return f.r *= .15, f.g *= .15, f.b *= .15, f } function Zt(f, p, g) { let T = 0, D = 0, B = 0; const $ = Math.floor(f * 6), be = f * 6 - $, ye = g * (1 - p), We = g * (1 - be * p), xt = g * (1 - (1 - be) * p); switch ($ % 6) { case 0: T = g, D = xt, B = ye; break; case 1: T = We, D = g, B = ye; break; case 2: T = ye, D = g, B = xt; break; case 3: T = ye, D = We, B = g; break; case 4: T = xt, D = ye, B = g; break; case 5: T = g, D = ye, B = We; break }return { r: T, g: D, b: B } } function zn(f, p, g) { const T = g - p; return (f - p) % T + p } window.addEventListener("mousedown", f => { const p = s[0], g = _(f.clientX), T = _(f.clientY); xe(p, -1, g, T), ue(p) }); function fi(f) { const p = s[0], g = _(f.clientX), T = _(f.clientY), D = ft(); S(), Ye(p, g, T, D), document.body.removeEventListener("mousemove", fi) } document.body.addEventListener("mousemove", fi), window.addEventListener("mousemove", f => { const p = s[0], g = _(f.clientX), T = _(f.clientY), D = p.color; Ye(p, g, T, D) }); function ui(f) { const p = f.targetTouches, g = s[0]; for (let T = 0; T < p.length; T++) { const D = _(p[T].clientX), B = _(p[T].clientY); S(), xe(g, p[T].identifier, D, B) } document.body.removeEventListener("touchstart", ui) } document.body.addEventListener("touchstart", ui), window.addEventListener("touchstart", f => { const p = f.targetTouches, g = s[0]; for (let T = 0; T < p.length; T++) { const D = _(p[T].clientX), B = _(p[T].clientY); xe(g, p[T].identifier, D, B) } }, !1), window.addEventListener("touchmove", f => { const p = f.targetTouches, g = s[0]; for (let T = 0; T < p.length; T++) { const D = _(p[T].clientX), B = _(p[T].clientY); Ye(g, D, B, g.color) } }, !1), window.addEventListener("touchend", f => { const p = f.changedTouches, g = s[0]; for (let T = 0; T < p.length; T++)Jt(g) }), Rt(() => t.simResolution, f => { l.SIM_RESOLUTION = f, h() }), Rt(() => t.dyeResolution, f => { l.DYE_RESOLUTION = f, h() }), Rt(() => t.shading, f => { l.SHADING = f, b() }), S()
          }), (n, s) => (ni(), si("div", { class: Yt(Qr(Hn)("pointer-events-none fixed left-0 top-0 z-50 size-full", t.class)) }, [oi("canvas", { id: "fluid", ref_key: "canvasRef", ref: i, class: "block fixed inset-0 w-screen h-screen" }, null, 512)], 2))
        }
      }), ml = dn({ __name: "FallingStarsBg", props: { color: { default: "#FFF" }, count: { default: 200 }, class: {} }, setup(e) { const t = e, r = sn(null); let i = 0, n = [], s = null; ti(() => { const d = r.value; if (d) { window.addEventListener("resize", v), v(), i = d.width / 2, n = []; for (let m = 0; m < t.count; m++)n.push({ x: (Math.random() - .5) * 2 * d.width, y: (Math.random() - .5) * 2 * d.height, z: Math.random() * d.width, speed: Math.random() * 5 + 2 }); u() } }); function l() { let d = t.color.replace(/^#/, ""); d.length === 3 && (d = d.split("").map(N => N + N).join("")); const m = parseInt(d, 16), w = m >> 16 & 255, C = m >> 8 & 255, P = m & 255; return { r: w, g: C, b: P } } function o(d) { const m = r.value; if (!m || (s = m.getContext("2d"), !s)) return; const w = i / (i + d.z), C = m.width / 2 + d.x * w, P = m.height / 2 + d.y * w, N = Math.max(w * 3, .5), te = i / (i + d.z + d.speed * 15), H = m.width / 2 + d.x * te, G = m.height / 2 + d.y * te, U = l(); s.save(), s.strokeStyle = `rgba(${U.r}, ${U.g}, ${U.b}, 0.2)`, s.lineWidth = N * 2.5, s.shadowBlur = 35, s.shadowColor = `rgba(${U.r}, ${U.g}, ${U.b}, 0.8)`, s.beginPath(), s.moveTo(C, P), s.lineTo(H, G), s.stroke(), s.restore(), s.strokeStyle = `rgba(${U.r}, ${U.g}, ${U.b}, 0.6)`, s.lineWidth = N, s.beginPath(), s.moveTo(C, P), s.lineTo(H, G), s.stroke(), s.fillStyle = `rgba(${U.r}, ${U.g}, ${U.b}, 1)`, s.beginPath(), s.arc(C, P, N / 4, 0, Math.PI * 2), s.fill() } function u() { const d = r.value; d && (s = d.getContext("2d"), s && (s.clearRect(0, 0, d.width, d.height), n.forEach(m => { o(m), m.z -= m.speed, m.z <= 0 && (m.z = d.width, m.x = (Math.random() - .5) * 2 * d.width, m.y = (Math.random() - .5) * 2 * d.height) }), requestAnimationFrame(u))) } function v() { const d = r.value; d && (d.width = d.clientWidth, d.height = d.clientHeight) } return (d, m) => (ni(), si("canvas", { ref_key: "starsCanvas", ref: r, class: Yt(Qr(Hn)("absolute inset-0 w-full h-full", d.$props.class)) }, null, 2)) } }), vl = (e, t) => { const r = e.__vccOpts || e; for (const [i, n] of t) r[i] = n; return r }, _l = { __name: "App", setup(e) { return (t, r) => (ni(), si(Be, null, [Xe(gl, { style: { position: "fixed", inset: "0", "z-index": "0" } }), Xe(ml, { style: { position: "fixed", inset: "0", "z-index": "1", "pointer-events": "none", opacity: ".85" } }), r[0] || (r[0] = Po('<div class="hero" data-v-f3db3a3d><div class="card expandIn" data-v-f3db3a3d><div class="avatarBlock" data-v-f3db3a3d><img class="avatar" src="https://love.qmys.fun/798712402647584768.png" alt="avatar" data-v-f3db3a3d><div class="vline" data-v-f3db3a3d></div></div><div class="divider" data-v-f3db3a3d></div><h1 class="title" data-v-f3db3a3d>千木の个人引导页</h1><p class="subtitle" data-v-f3db3a3d>我是千木 · 博客与图床入口汇聚于此</p><div class="divider large" data-v-f3db3a3d></div><div class="actions" data-v-f3db3a3d><a href="http://117.72.215.94:8080/" class="btn" data-v-f3db3a3d>千木博客</a><a href="http://117.72.215.94:8081/" class="btn" data-v-f3db3a3d>千木图床</a></div></div></div>', 1))], 64)) } }, xl = vl(_l, [["__scopeId", "data-v-f3db3a3d"]]); dl(xl).mount("#app");</script>
  <style rel="stylesheet" crossorigin>
    /*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */
    @layer properties {
      @supports ((-webkit-hyphens:none) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))) {

        *,
        :before,
        :after,
        ::backdrop {
          --tw-rotate-x: initial;
          --tw-rotate-y: initial;
          --tw-rotate-z: initial;
          --tw-skew-x: initial;
          --tw-skew-y: initial;
          --tw-border-style: solid;
          --tw-blur: initial;
          --tw-brightness: initial;
          --tw-contrast: initial;
          --tw-grayscale: initial;
          --tw-hue-rotate: initial;
          --tw-invert: initial;
          --tw-opacity: initial;
          --tw-saturate: initial;
          --tw-sepia: initial;
          --tw-drop-shadow: initial;
          --tw-drop-shadow-color: initial;
          --tw-drop-shadow-alpha: 100%;
          --tw-drop-shadow-size: initial;
          --tw-backdrop-blur: initial;
          --tw-backdrop-brightness: initial;
          --tw-backdrop-contrast: initial;
          --tw-backdrop-grayscale: initial;
          --tw-backdrop-hue-rotate: initial;
          --tw-backdrop-invert: initial;
          --tw-backdrop-opacity: initial;
          --tw-backdrop-saturate: initial;
          --tw-backdrop-sepia: initial;
          --tw-duration: initial
        }
      }
    }

    .pointer-events-none {
      pointer-events: none
    }

    .absolute {
      position: absolute
    }

    .fixed {
      position: fixed
    }

    .relative {
      position: relative
    }

    .z-50 {
      z-index: 50
    }

    .block {
      display: block
    }

    .flex {
      display: flex
    }

    .inline-block {
      display: inline-block
    }

    .size-full {
      width: 100%;
      height: 100%
    }

    .h-full {
      height: 100%
    }

    .h-screen {
      height: 100vh
    }

    .w-full {
      width: 100%
    }

    .w-screen {
      width: 100vw
    }

    .flex-1 {
      flex: 1
    }

    .transform {
      transform: var(--tw-rotate-x, )var(--tw-rotate-y, )var(--tw-rotate-z, )var(--tw-skew-x, )var(--tw-skew-y, )
    }

    .cursor-pointer {
      cursor: pointer
    }

    .resize {
      resize: both
    }

    .overflow-hidden {
      overflow: hidden
    }

    .border {
      border-style: var(--tw-border-style);
      border-width: 1px
    }

    .object-cover {
      -o-object-fit: cover;
      object-fit: cover
    }

    .filter {
      filter: var(--tw-blur, )var(--tw-brightness, )var(--tw-contrast, )var(--tw-grayscale, )var(--tw-hue-rotate, )var(--tw-invert, )var(--tw-saturate, )var(--tw-sepia, )var(--tw-drop-shadow, )
    }

    .backdrop-filter {
      -webkit-backdrop-filter: var(--tw-backdrop-blur, )var(--tw-backdrop-brightness, )var(--tw-backdrop-contrast, )var(--tw-backdrop-grayscale, )var(--tw-backdrop-hue-rotate, )var(--tw-backdrop-invert, )var(--tw-backdrop-opacity, )var(--tw-backdrop-saturate, )var(--tw-backdrop-sepia, );
      backdrop-filter: var(--tw-backdrop-blur, )var(--tw-backdrop-brightness, )var(--tw-backdrop-contrast, )var(--tw-backdrop-grayscale, )var(--tw-backdrop-hue-rotate, )var(--tw-backdrop-invert, )var(--tw-backdrop-opacity, )var(--tw-backdrop-saturate, )var(--tw-backdrop-sepia, )
    }

    .transition {
      transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, backdrop-filter, display, visibility, content-visibility, overlay, pointer-events;
      transition-timing-function: var(--tw-ease, ease);
      transition-duration: var(--tw-duration, 0s)
    }

    .transition-all {
      transition-property: all;
      transition-timing-function: var(--tw-ease, ease);
      transition-duration: var(--tw-duration, 0s)
    }

    .duration-500 {
      --tw-duration: .5s;
      transition-duration: .5s
    }

    .will-change-transform {
      will-change: transform
    }

    @media (hover:hover) {
      .hover\:flex-\[3\]:hover {
        flex: 3
      }
    }

    html,
    body {
      height: 100vh;
      margin: 0
    }

    #app {
      width: 100vw;
      height: 100vh
    }

    body {
      overflow: hidden
    }

    :root {
      color-scheme: light dark;
      color: #ffffffde;
      font-synthesis: none;
      text-rendering: optimizeLegibility;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      background-color: #242424;
      font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
      font-weight: 400;
      line-height: 1.5
    }

    a {
      color: #646cff;
      -webkit-text-decoration: inherit;
      text-decoration: inherit;
      font-weight: 500
    }

    a:hover {
      color: #535bf2
    }

    body {
      place-items: center;
      min-width: 320px;
      min-height: 100vh;
      margin: 0;
      display: flex
    }

    h1 {
      font-size: 3.2em;
      line-height: 1.1
    }

    button {
      cursor: pointer;
      background-color: #1a1a1a;
      border: 1px solid #0000;
      border-radius: 8px;
      padding: .6em 1.2em;
      font-family: inherit;
      font-size: 1em;
      font-weight: 500;
      transition: border-color .25s
    }

    button:hover {
      border-color: #646cff
    }

    button:focus,
    button:focus-visible {
      outline: 4px auto -webkit-focus-ring-color
    }

    .card {
      padding: 2em
    }

    #app {
      text-align: center;
      max-width: 1280px;
      margin: 0 auto;
      padding: 2rem
    }

    @media (prefers-color-scheme:light) {
      :root {
        color: #213547;
        background-color: #fff
      }

      a:hover {
        color: #747bff
      }

      button {
        background-color: #f9f9f9
      }
    }

    @property --tw-rotate-x {
      syntax: "*";
      inherits: false
    }

    @property --tw-rotate-y {
      syntax: "*";
      inherits: false
    }

    @property --tw-rotate-z {
      syntax: "*";
      inherits: false
    }

    @property --tw-skew-x {
      syntax: "*";
      inherits: false
    }

    @property --tw-skew-y {
      syntax: "*";
      inherits: false
    }

    @property --tw-border-style {
      syntax: "*";
      inherits: false;
      initial-value: solid
    }

    @property --tw-blur {
      syntax: "*";
      inherits: false
    }

    @property --tw-brightness {
      syntax: "*";
      inherits: false
    }

    @property --tw-contrast {
      syntax: "*";
      inherits: false
    }

    @property --tw-grayscale {
      syntax: "*";
      inherits: false
    }

    @property --tw-hue-rotate {
      syntax: "*";
      inherits: false
    }

    @property --tw-invert {
      syntax: "*";
      inherits: false
    }

    @property --tw-opacity {
      syntax: "*";
      inherits: false
    }

    @property --tw-saturate {
      syntax: "*";
      inherits: false
    }

    @property --tw-sepia {
      syntax: "*";
      inherits: false
    }

    @property --tw-drop-shadow {
      syntax: "*";
      inherits: false
    }

    @property --tw-drop-shadow-color {
      syntax: "*";
      inherits: false
    }

    @property --tw-drop-shadow-alpha {
      syntax: "<percentage>";
      inherits: false;
      initial-value: 100%
    }

    @property --tw-drop-shadow-size {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-blur {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-brightness {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-contrast {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-grayscale {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-hue-rotate {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-invert {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-opacity {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-saturate {
      syntax: "*";
      inherits: false
    }

    @property --tw-backdrop-sepia {
      syntax: "*";
      inherits: false
    }

    @property --tw-duration {
      syntax: "*";
      inherits: false
    }

    .hero[data-v-f3db3a3d] {
      position: relative;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      width: 100%;
      padding: 0 16px;
      color: #fffffff2
    }

    .card[data-v-f3db3a3d] {
      width: 100%;
      max-width: 860px
    }

    .expandIn[data-v-f3db3a3d] {
      animation: expandIn-f3db3a3d .9s cubic-bezier(.21, 1, .29, 1) both
    }

    @keyframes expandIn-f3db3a3d {
      0% {
        opacity: 0;
        transform: scale(.96);
        clip-path: inset(50% 50% 50% 50% round 24px)
      }

      60% {
        opacity: 1;
        transform: scale(1.02);
        clip-path: inset(0 0 0 0 round 24px)
      }

      to {
        opacity: 1;
        transform: scale(1)
      }
    }

    .avatarBlock[data-v-f3db3a3d] {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px
    }

    .avatar[data-v-f3db3a3d] {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      box-shadow: 0 10px 30px #00000059;
      -o-object-fit: cover;
      object-fit: cover;
      border: 2px solid rgba(255, 255, 255, .7)
    }

    .vline[data-v-f3db3a3d] {
      width: 1px;
      height: 40px;
      background: #fff9
    }

    .divider[data-v-f3db3a3d] {
      margin-top: 16px;
      height: 1px;
      width: 100%;
      background: #ad9a9a80
    }

    .divider.large[data-v-f3db3a3d] {
      margin-top: 40px
    }

    .title[data-v-f3db3a3d] {
      margin-top: 28px;
      text-align: center;
      font-weight: 800;
      letter-spacing: .02em;
      font-size: clamp(32px, 6vw, 60px)
    }

    .subtitle[data-v-f3db3a3d] {
      margin-top: 18px;
      text-align: center;
      color: #ffffffe6;
      font-size: clamp(14px, 2.2vw, 18px)
    }

    .actions[data-v-f3db3a3d] {
      margin-top: 24px;
      display: flex;
      gap: 20px;
      justify-content: center
    }

    .btn[data-v-f3db3a3d] {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 12px 22px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, .75);
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px);
      color: #fff;
      text-decoration: none;
      font-size: 16px;
      font-weight: 600;
      transition: background .2s ease, transform .15s ease
    }

    .btn[data-v-f3db3a3d]:hover {
      background: #ffffff1f;
      transform: translateY(-1px)
    }

    .btn[data-v-f3db3a3d]:active {
      transform: translateY(0)
    }
  </style>
</head>

<body>
  <div id="app"></div>
</body>

</html>